text,choices
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Determine the structure and initialize parameters
        int START_X = -50;
int START_Y = -50;
int NUM_COLUMNS = 4;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 5;
boolean isUpsideDown = true;
boolean isColumn = true;
String input = ""4, 4, 4, 4"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'structure': 'column', 'numColumns': '4', 'numBricksPerColumn': 'constant', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '5', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = -50;;
int START_Y = int START_Y = -50;;
int NUM_ROWS = 6;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'numBricksBase': '6', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '0', 'rowSeparation': '0', 'horizontalOffset': '20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int START_X = -50;
int START_Y = 100;
int NUM_ROWS = 4;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 2;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.BLACK);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'numBricksBase': '4', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '5', 'rowSeparation': '10', 'horizontalOffset': '20', 'holeProbability': '2', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 5;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 40;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = 50;
int START_Y_FIRST_ROW = 150;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 5;
int BRICK_WIDTH_SECOND_ROW = 40;
int BRICK_HEIGHT_SECOND_ROW = 20;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = -1;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 5;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '40', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = 50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 150;', 'brickColor': 'Color.BLACK', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 5;', 'brickWidthSecondRow': '40', 'brickHeightSecondRow': '20', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = -1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.YELLOW);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '40', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize structure parameters
        int START_X = 100;
int START_Y = 50;
int NUM_ROWS = 8;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 5;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 2;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6, 7, 8"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.BLACK);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'numBricksBase': '8', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': '0', 'rowSeparation': '5', 'horizontalOffset': '20', 'holeProbability': '2', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROGUE_BRICK_INDEX = -1;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.YELLOW);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 5;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 50;;
int START_Y = int START_Y = 50;;
int NUM_ROWS = 7;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = true;
String input = ""7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.MAGENTA);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'numBricksBase': '7', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '10', 'rowSeparation': '0', 'horizontalOffset': '20', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 10;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.GREEN);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '10', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Determine the shape and initialize parameters
        int START_X = 100;
int START_Y = -50;
int NUM_ROWS = 16;
int NUM_BRICKS_BASE = 16;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 5;
int ROW_SEP = 10;
boolean isUpsideDown = false;
boolean isRightTriangle = true;
String input = ""16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'shape': 'rightTriangle', 'numBricksBase': '16', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '5', 'rowSeparation': '10', 'isUpsideDown': 'false', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 600);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 100;;
int START_Y = int START_Y = -50;;
int NUM_ROWS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 5;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = true;
String input = ""3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '600', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'numBricksBase': '3', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '0', 'rowSeparation': '5', 'horizontalOffset': '20', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.GRAY);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 6;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 8;;
int OFFSET = int OFFSET = -20;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 5;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = 2;
int START_X = 100;
int START_Y = 50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.MAGENTA);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 6;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 8;', 'offset': 'int OFFSET = -20;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 5;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 2;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_Y = 40;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = 40;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 6;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 50;
int START_Y = 50;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.YELLOW);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 6;', 'offset': 'int OFFSET = 20;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(true);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 8;;
int OFFSET = int OFFSET = -20;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = 1;
int ROGUE_DIAGONAL_INDEX = 1;
int START_X = 50;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 8;', 'offset': 'int OFFSET = -20;', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 1;', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400);
        // Create a rectangle with the specified position 
        int x = -75; int y = -75;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 100, 50);
        // Add color, optional 
        rect.setFilled(true); rect.setColor(Color.GREEN);

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{OffCanvas}', 'OffCanvas': 'setSize(600,400);', 'initialPointLocation': '{OffCanvasPositions}', 'offCanvasPosition': 'int x = -75; int y = -75;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 100, 50);', 'rectangleColor': 'rect.setFilled(true); rect.setColor(Color.GREEN);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 3;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = 2;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = -50;
int START_Y = 50;
boolean isRogueRow = true;
boolean isRogueDiagonal = true;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.ORANGE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 3;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'offset': 'int OFFSET = 20;', 'brickWidth': '20', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 10;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 2;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = 1;
int START_Y = -40;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLUE);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 1;', 'startYPosition': 'int START_Y = -40;', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize structure parameters
        int START_X = 50;
int START_Y = 50;
int NUM_ROWS = 8;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 5;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 3;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6, 7, 8"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.GRAY);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'numBricksBase': '8', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '5', 'rowSeparation': '0', 'horizontalOffset': '20', 'holeProbability': '3', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 600);

        // Determine the structure and initialize parameters
        int START_X = -50;
int START_Y = 100;
int NUM_COLUMNS = 8;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 5;
boolean isUpsideDown = true;
boolean isColumn = true;
String input = ""1, 2, 3, 4, 5, 6, 7, 8"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '600', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'structure': 'column', 'numColumns': '8', 'numBricksPerColumn': 'varying', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '5', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the shape and initialize parameters
        int START_X = 50;
int START_Y = -50;
int NUM_ROWS = 16;
int NUM_BRICKS_BASE = 16;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;
boolean isUpsideDown = true;
boolean isRightTriangle = true;
String input = ""1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'shape': 'rightTriangle', 'numBricksBase': '16', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': '0', 'rowSeparation': '0', 'isUpsideDown': 'true', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = -50;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize structure parameters
        int START_X = 50;
int START_Y = -50;
int NUM_ROWS = 6;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 3;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.YELLOW);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = -50;', 'numBricksBase': '6', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '10', 'rowSeparation': '10', 'horizontalOffset': '20', 'holeProbability': '3', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 8;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 20;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = 1;
int START_X_FIRST_ROW = -100;
int START_Y_FIRST_ROW = 150;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 7;
int BRICK_WIDTH_SECOND_ROW = 40;
int BRICK_HEIGHT_SECOND_ROW = 20;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = -1;
int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 8;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '20', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = 1;', 'startXFirstRow': 'int START_X_FIRST_ROW = -100;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 150;', 'brickColor': 'Color.BLACK', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 7;', 'brickWidthSecondRow': '40', 'brickHeightSecondRow': '20', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = -1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 4;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROGUE_BRICK_INDEX = -1;
int START_Y = 40;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.YELLOW);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 4;', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 5;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = 40;', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(800,400+60)
        // Create a rectangle with the specified position 
        int x = 50; int y = 50;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 200, 100);
        // Add color, optional 
        rect.setFilled(true); rect.setColor(Color.RED);

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(800,400+60)', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 50; int y = 50;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 200, 100);', 'rectangleColor': 'rect.setFilled(true); rect.setColor(Color.RED);'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400);
        // Create a rectangle with the specified position 
        int x = 100; int y = 100;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 100, 50);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{OffCanvas}', 'OffCanvas': 'setSize(600,400);', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 100; int y = 100;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 100, 50);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 8;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 30;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = -50;
int START_Y_FIRST_ROW = -50;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GREEN);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 7;
int BRICK_WIDTH_SECOND_ROW = 40;
int BRICK_HEIGHT_SECOND_ROW = 30;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = 2;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GREEN);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 8;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '30', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = -50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = -50;', 'brickColor': 'Color.GREEN', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 7;', 'brickWidthSecondRow': '40', 'brickHeightSecondRow': '30', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = 2;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': 'add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 300);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = 1;
int START_Y = getHeight() / 2;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GREEN);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '300', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '30', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 1;', 'startYPosition': 'int START_Y = getHeight() / 2;', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 6;
int BRICK_WIDTH_FIRST_ROW = 30;
int BRICK_HEIGHT_FIRST_ROW = 30;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = 50;
int START_Y_FIRST_ROW = -50;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.MAGENTA);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 8;
int BRICK_WIDTH_SECOND_ROW = 20;
int BRICK_HEIGHT_SECOND_ROW = 30;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = -1;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.MAGENTA);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 6;', 'brickWidthFirstRow': '30', 'brickHeightFirstRow': '30', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = 50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = -50;', 'brickColor': 'Color.MAGENTA', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 8;', 'brickWidthSecondRow': '20', 'brickHeightSecondRow': '30', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = -1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.YELLOW);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '80', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 600);

        // Determine the structure and initialize parameters
        int START_X = 50;
int START_Y = 50;
int NUM_COLUMNS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 5;
boolean isUpsideDown = false;
boolean isColumn = false;
String input = ""3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '600', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'structure': 'diagonal', 'numColumns': '3', 'numBricksPerColumn': 'varying', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '5', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 100;;
int START_Y = int START_Y = -50;;
int NUM_ROWS = 3;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = -20;
boolean isUpsideDown = false;
String input = ""1, 2, 3"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.MAGENTA);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'numBricksBase': '3', 'brickWidth': '20', 'brickHeight': '30', 'brickSeparation': '0', 'rowSeparation': '0', 'horizontalOffset': '-20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = 100;
int START_Y = -50;
int NUM_COLUMNS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
boolean isUpsideDown = true;
boolean isColumn = true;
String input = ""1, 2, 3"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'structure': 'column', 'numColumns': '3', 'numBricksPerColumn': 'varying', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '0', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400+60);
        // Create a rectangle with the specified position 
        int x = 100; int y = 100;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 100, 50);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(600,400+60);', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 100; int y = 100;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 100, 50);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 50;;
int START_Y = int START_Y = 100;;
int NUM_ROWS = 4;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 5;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 100;', 'numBricksBase': '4', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '0', 'rowSeparation': '5', 'horizontalOffset': '20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 12;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '12', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 7;
int BRICK_WIDTH_FIRST_ROW = 30;
int BRICK_HEIGHT_FIRST_ROW = 20;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = 2;
int START_X_FIRST_ROW = 100;
int START_Y_FIRST_ROW = 100;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 3;
int BRICK_WIDTH_SECOND_ROW = 20;
int BRICK_HEIGHT_SECOND_ROW = 40;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = 2;
int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 7;', 'brickWidthFirstRow': '30', 'brickHeightFirstRow': '20', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = 2;', 'startXFirstRow': 'int START_X_FIRST_ROW = 100;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 100;', 'brickColor': 'Color.BLACK', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 3;', 'brickWidthSecondRow': '20', 'brickHeightSecondRow': '40', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = 2;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 20;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 8;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 5;
int ROGUE_ROW_INDEX = 2;
int ROGUE_DIAGONAL_INDEX = 1;
int START_X = -50;
int START_Y = 50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.GREEN);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 8;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 5;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 2;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize structure parameters
        int START_X = 50;
int START_Y = 50;
int NUM_ROWS = 3;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = -20;
int HOLE_PROBABILITY = 2;
boolean isUpsideDown = false;
String input = ""1, 2, 3"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.BLUE);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'numBricksBase': '3', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': '10', 'rowSeparation': '0', 'horizontalOffset': '-20', 'holeProbability': '2', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = 100;
int START_Y = 100;
int NUM_COLUMNS = 3;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
boolean isUpsideDown = false;
boolean isColumn = true;
String input = ""3, 3, 3"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'structure': 'column', 'numColumns': '3', 'numBricksPerColumn': 'constant', 'brickWidth': '30', 'brickHeight': '30', 'brickSeparation': '0', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Determine the structure and initialize parameters
        int START_X = -50;
int START_Y = 50;
int NUM_COLUMNS = 4;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
boolean isUpsideDown = false;
boolean isColumn = false;
String input = ""4, 4, 4, 4"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'structure': 'diagonal', 'numColumns': '4', 'numBricksPerColumn': 'constant', 'brickWidth': '20', 'brickHeight': '30', 'brickSeparation': '0', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_X = 100;
int START_Y = getHeight() + 60;
boolean isDiagonal = true;
boolean isUpRight = true;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.MAGENTA);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = 100;', 'startYPosition': 'int START_Y = getHeight() + 60;', 'isDiagonal': 'boolean isDiagonal = true;', 'isUpRight': 'boolean isUpRight = true;', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 11;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '11', 'brickWidth': '40', 'brickHeight': '40', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 6;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 5;
int ROGUE_BRICK_INDEX = 2;
int START_Y = getHeight() / 2;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 6;', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 5;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 2;', 'startYPosition': 'int START_Y = getHeight() / 2;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 300);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROGUE_BRICK_INDEX = -1;
int START_Y = 40;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.YELLOW);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '300', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 10;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = 40;', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(true);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = -50;;
int START_Y = int START_Y = 100;;
int NUM_ROWS = 7;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6, 7"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'numBricksBase': '7', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '10', 'horizontalOffset': '20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 300);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_Y = -40;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.ORANGE);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '300', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = -40;', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(800,400+60)
        // Create a rectangle with the specified position 
        int x = -75; int y = -75;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 50, 100);
        // Add color, optional 
        rect.setFilled(true); rect.setColor(Color.MAGENTA);

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(800,400+60)', 'initialPointLocation': '{OffCanvasPositions}', 'offCanvasPosition': 'int x = -75; int y = -75;', 'rectangleOrientation': '{StandingRectangle}', 'standingRectangleSize': 'GRect rect = new GRect(x, y, 50, 100);', 'rectangleColor': 'rect.setFilled(true); rect.setColor(Color.MAGENTA);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 8;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = 1;
int START_X = -50;
int START_Y = 50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 8;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'brickWidth': '30', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400+60);
        // Create a rectangle with the specified position 
        int x = 75; int y = 75;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 100, 200);
        // Add color, optional 
        rect.setFilled(true); rect.setColor(Color.RED);

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(600,400+60);', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 75; int y = 75;', 'rectangleOrientation': '{StandingRectangle}', 'standingRectangleSize': 'GRect rect = new GRect(x, y, 100, 200);', 'rectangleColor': 'rect.setFilled(true); rect.setColor(Color.RED);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 300);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '300', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 7;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 20;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = 100;
int START_Y_FIRST_ROW = 150;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 7;
int BRICK_WIDTH_SECOND_ROW = 20;
int BRICK_HEIGHT_SECOND_ROW = 30;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = 2;
int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 7;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '20', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = 100;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 150;', 'brickColor': 'Color.GRAY', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 7;', 'brickWidthSecondRow': '20', 'brickHeightSecondRow': '30', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = 2;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 100;;
int START_Y = int START_Y = -50;;
int NUM_ROWS = 6;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = true;
String input = ""6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'numBricksBase': '6', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '10', 'horizontalOffset': '20', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 300);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 4;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 5;
int ROGUE_BRICK_INDEX = -1;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '300', 'numBricks': 'int NUM_BRICKS = 4;', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 5;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 10;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.ORANGE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 200);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.MAGENTA);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '200', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 7;
int NUM_ROWS = 40;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 10;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                brick.setColor(Color.YELLOW);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '80', 'brickHeight': '10', 'brickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 10;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '10', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(true);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 300);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = 1;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.YELLOW);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '300', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 1;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = -50;;
int START_Y = int START_Y = -50;;
int NUM_ROWS = 6;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 5;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.MAGENTA);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'numBricksBase': '6', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '0', 'rowSeparation': '5', 'horizontalOffset': '20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.MAGENTA);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 7;
int NUM_ROWS = 10;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '80', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 600);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 6;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int OFFSET = int OFFSET = -20;;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 5;
int ROGUE_ROW_INDEX = 1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 100;
int START_Y = 50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.YELLOW);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '600', 'numRows': 'int NUM_ROWS = 6;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'offset': 'int OFFSET = -20;', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 10;', 'rowSeparation': 'int ROW_SEP = 5;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = 2;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 50;
int START_Y = -50;
boolean isRogueRow = true;
boolean isRogueDiagonal = true;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'offset': 'int OFFSET = 20;', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 10;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 2;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = 1;
int START_X = 100;
int START_Y = 100;
boolean isDiagonal = false;
boolean isUpRight = false;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '20', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 1;', 'startXPosition': 'int START_X = 100;', 'startYPosition': 'int START_Y = 100;', 'isDiagonal': 'boolean isDiagonal = false;', 'isUpRight': 'boolean isUpRight = false;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = 2;
int START_X = -50;
int START_Y = -100;
boolean isDiagonal = true;
boolean isUpRight = false;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 2;', 'startXPosition': 'int START_X = -50;', 'startYPosition': 'int START_Y = -100;', 'isDiagonal': 'boolean isDiagonal = true;', 'isUpRight': 'boolean isUpRight = false;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = -50;
int START_Y = 100;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.YELLOW);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 3;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 8;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = 2;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 100;
int START_Y = 100;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.YELLOW);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'numRows': 'int NUM_ROWS = 3;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 8;', 'offset': 'int OFFSET = 20;', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 2;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.ORANGE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '80', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '80', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Determine the shape and initialize parameters
        int START_X = 100;
int START_Y = 100;
int NUM_ROWS = 10;
int NUM_BRICKS_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
int ROW_SEP = 0;
boolean isUpsideDown = false;
boolean isRightTriangle = false;
String input = ""10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'shape': 'trapezoid', 'numBricksBase': '13', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '10', 'rowSeparation': '0', 'isUpsideDown': 'false', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 4;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
int ROGUE_BRICK_INDEX = -1;
int START_Y = -40;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.YELLOW);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 4;', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 10;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = -40;', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 20;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLUE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 8;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = 2;
int ROGUE_DIAGONAL_INDEX = 2;
int START_X = 100;
int START_Y = 50;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 8;', 'offset': 'int OFFSET = 20;', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 5;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 2;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 2;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the shape and initialize parameters
        int START_X = -50;
int START_Y = -50;
int NUM_ROWS = 15;
int NUM_BRICKS_BASE = 15;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;
boolean isUpsideDown = true;
boolean isRightTriangle = true;
String input = ""1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'shape': 'rightTriangle', 'numBricksBase': '15', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '0', 'rowSeparation': '0', 'isUpsideDown': 'true', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.GREEN);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 20;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the shape and initialize parameters
        int START_X = 50;
int START_Y = -50;
int NUM_ROWS = 15;
int NUM_BRICKS_BASE = 15;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 0;
boolean isUpsideDown = false;
boolean isRightTriangle = true;
String input = ""15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'shape': 'rightTriangle', 'numBricksBase': '15', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': '10', 'rowSeparation': '0', 'isUpsideDown': 'false', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = -50;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 50;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'offset': 'int OFFSET = 20;', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 5;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = 2;
int START_X = -50;
int START_Y = 50;
boolean isRogueRow = true;
boolean isRogueDiagonal = true;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.ORANGE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'numRows': 'int NUM_ROWS = 5;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'offset': 'int OFFSET = 20;', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 2;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 10;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.MAGENTA);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '10', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': 'add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = 50;
int START_Y = 50;
int NUM_COLUMNS = 6;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
boolean isUpsideDown = false;
boolean isColumn = false;
String input = ""6, 6, 6, 6, 6, 6"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'structure': 'diagonal', 'numColumns': '6', 'numBricksPerColumn': 'constant', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': '0', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Determine the structure and initialize parameters
        int START_X = -50;
int START_Y = 100;
int NUM_COLUMNS = 8;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
boolean isUpsideDown = false;
boolean isColumn = false;
String input = ""8, 8, 8, 8, 8, 8, 8, 8"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.YELLOW);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'structure': 'diagonal', 'numColumns': '8', 'numBricksPerColumn': 'constant', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': '0', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize structure parameters
        int START_X = -50;
int START_Y = 100;
int NUM_ROWS = 8;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 10;
int ROW_SEP = 5;
int HORIZONTAL_OFFSET = -20;
int HOLE_PROBABILITY = 1;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6, 7, 8"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.ORANGE);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'numBricksBase': '8', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '10', 'rowSeparation': '5', 'horizontalOffset': '-20', 'holeProbability': '1', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Determine the shape and initialize parameters
        int START_X = -50;
int START_Y = -50;
int NUM_ROWS = 16;
int NUM_BRICKS_BASE = 16;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;
boolean isUpsideDown = false;
boolean isRightTriangle = true;
String input = ""16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'shape': 'rightTriangle', 'numBricksBase': '16', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '0', 'rowSeparation': '0', 'isUpsideDown': 'false', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 4;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 5;
int ROGUE_BRICK_INDEX = 2;
int START_Y = getHeight() / 2;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.YELLOW);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 4;', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 5;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 2;', 'startYPosition': 'int START_Y = getHeight() / 2;', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters
        int NUM_BRICKS = 6;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = 1;
int START_X = 50;
int START_Y = getHeight() + 60;
boolean isDiagonal = false;
boolean isUpRight = true;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.GREEN);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numBricks': 'int NUM_BRICKS = 6;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 1;', 'startXPosition': 'int START_X = 50;', 'startYPosition': 'int START_Y = getHeight() + 60;', 'isDiagonal': 'boolean isDiagonal = false;', 'isUpRight': 'boolean isUpRight = true;', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 4;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = 1;
int START_X = 100;
int START_Y = 100;
boolean isRogueRow = true;
boolean isRogueDiagonal = false;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'numRows': 'int NUM_ROWS = 4;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Determine the shape and initialize parameters
        int START_X = 50;
int START_Y = -50;
int NUM_ROWS = 16;
int NUM_BRICKS_BASE = 16;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;
boolean isUpsideDown = false;
boolean isRightTriangle = true;
String input = ""16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLUE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'shape': 'rightTriangle', 'numBricksBase': '16', 'brickWidth': '20', 'brickHeight': '40', 'brickSeparation': '0', 'rowSeparation': '0', 'isUpsideDown': 'false', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = -50;', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the shape and initialize parameters
        int START_X = 100;
int START_Y = 50;
int NUM_ROWS = 15;
int NUM_BRICKS_BASE = 15;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;
boolean isUpsideDown = false;
boolean isRightTriangle = true;
String input = ""15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'shape': 'rightTriangle', 'numBricksBase': '15', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '0', 'rowSeparation': '0', 'isUpsideDown': 'false', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 12;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '12', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 20;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400);
        // Create a rectangle with the specified position 
        int x = 200; int y = 50;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 100, 200);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{OffCanvas}', 'OffCanvas': 'setSize(600,400);', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 200; int y = 50;', 'rectangleOrientation': '{StandingRectangle}', 'standingRectangleSize': 'GRect rect = new GRect(x, y, 100, 200);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Determine the structure and initialize parameters
        int START_X = int START_X = -50;;
int START_Y = int START_Y = 100;;
int NUM_ROWS = 4;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLUE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'numBricksBase': '4', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '10', 'horizontalOffset': '20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 4;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 50;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 4;', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 300);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 6;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 5;
int ROGUE_BRICK_INDEX = -1;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.YELLOW);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '300', 'numBricks': 'int NUM_BRICKS = 6;', 'brickWidth': '30', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 5;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 40;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 10;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '10', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 600);

        // Initialize structure parameters
        int START_X = 100;
int START_Y = -50;
int NUM_ROWS = 8;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 5;
int HORIZONTAL_OFFSET = -20;
int HOLE_PROBABILITY = 1;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6, 7, 8"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.BLACK);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '600', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'numBricksBase': '8', 'brickWidth': '20', 'brickHeight': '40', 'brickSeparation': '0', 'rowSeparation': '5', 'horizontalOffset': '-20', 'holeProbability': '1', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 6;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 10;
int ROGUE_BRICK_INDEX = 1;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 6;', 'brickWidth': '30', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 10;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 1;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400+60);
        // Create a rectangle with the specified position 
        int x = 50; int y = 50;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 100, 200);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(600,400+60);', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 50; int y = 50;', 'rectangleOrientation': '{StandingRectangle}', 'standingRectangleSize': 'GRect rect = new GRect(x, y, 100, 200);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 6;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = 1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 100;
int START_Y = -50;
boolean isRogueRow = true;
boolean isRogueDiagonal = true;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 6;', 'offset': 'int OFFSET = 20;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 10;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.GREEN);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 6;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 4;;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 10;
int ROGUE_ROW_INDEX = 2;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 100;
int START_Y = 100;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.YELLOW);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 6;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 4;', 'brickWidth': '30', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 10;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 2;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 5;
int BRICK_WIDTH_FIRST_ROW = 30;
int BRICK_HEIGHT_FIRST_ROW = 20;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = -100;
int START_Y_FIRST_ROW = 100;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 6;
int BRICK_WIDTH_SECOND_ROW = 40;
int BRICK_HEIGHT_SECOND_ROW = 20;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = -1;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 5;', 'brickWidthFirstRow': '30', 'brickHeightFirstRow': '20', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = -100;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 100;', 'brickColor': 'Color.BLACK', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 6;', 'brickWidthSecondRow': '40', 'brickHeightSecondRow': '20', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = -1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(800,400+60)
        // Create a rectangle with the specified position 
        int x = 150; int y = 150;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 200, 100);
        // Add color, optional 
        rect.setFilled(true); rect.setColor(Color.YELLOW);

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(800,400+60)', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 150; int y = 150;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 200, 100);', 'rectangleColor': 'rect.setFilled(true); rect.setColor(Color.YELLOW);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 10;
int NUM_ROWS = 40;
int BRICK_WIDTH = 60;
int BRICK_HEIGHT = 10;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLUE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '60', 'brickHeight': '10', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 20;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 50;;
int START_Y = int START_Y = 50;;
int NUM_ROWS = 7;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 5;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = true;
String input = ""7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'numBricksBase': '7', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '10', 'rowSeparation': '5', 'horizontalOffset': '20', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.YELLOW);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 100;
int START_Y = 50;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 8;
int BRICK_WIDTH_FIRST_ROW = 30;
int BRICK_HEIGHT_FIRST_ROW = 20;
int BRICK_SEP_FIRST_ROW = 5;
int ROGUE_BRICK_INDEX_FIRST_ROW = 1;
int START_X_FIRST_ROW = 100;
int START_Y_FIRST_ROW = 50;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 7;
int BRICK_WIDTH_SECOND_ROW = 40;
int BRICK_HEIGHT_SECOND_ROW = 20;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = -1;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 8;', 'brickWidthFirstRow': '30', 'brickHeightFirstRow': '20', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 5;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = 1;', 'startXFirstRow': 'int START_X_FIRST_ROW = 100;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 50;', 'brickColor': 'Color.BLACK', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 7;', 'brickWidthSecondRow': '40', 'brickHeightSecondRow': '20', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = -1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Determine the shape and initialize parameters
        int START_X = 50;
int START_Y = 50;
int NUM_ROWS = 16;
int NUM_BRICKS_BASE = 16;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 10;
int ROW_SEP = 0;
boolean isUpsideDown = false;
boolean isRightTriangle = true;
String input = ""16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GREEN);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'shape': 'rightTriangle', 'numBricksBase': '16', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '10', 'rowSeparation': '0', 'isUpsideDown': 'false', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 6;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 100;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 6;', 'offset': 'int OFFSET = 20;', 'brickWidth': '20', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 10;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 600);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = 1;
int ROGUE_DIAGONAL_INDEX = 1;
int START_X = -50;
int START_Y = 50;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.BLUE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '600', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 10;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize structure parameters
        int START_X = 100;
int START_Y = 50;
int NUM_ROWS = 7;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 5;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 2;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6, 7"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.YELLOW);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'numBricksBase': '7', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '5', 'rowSeparation': '10', 'horizontalOffset': '20', 'holeProbability': '2', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(800,400+60)
        // Create a rectangle with the specified position 
        int x = -150; int y = -150;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 50, 100);
        // Add color, optional 
        rect.setFilled(true); rect.setColor(Color.ORANGE);

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(800,400+60)', 'initialPointLocation': '{OffCanvasPositions}', 'offCanvasPosition': 'int x = -150; int y = -150;', 'rectangleOrientation': '{StandingRectangle}', 'standingRectangleSize': 'GRect rect = new GRect(x, y, 50, 100);', 'rectangleColor': 'rect.setFilled(true); rect.setColor(Color.ORANGE);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 12;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '12', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 11;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLUE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '11', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Determine the structure and initialize parameters
        int START_X = -50;
int START_Y = 50;
int NUM_COLUMNS = 5;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 5;
boolean isUpsideDown = false;
boolean isColumn = false;
String input = ""5, 5, 5, 5, 5"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'structure': 'diagonal', 'numColumns': '5', 'numBricksPerColumn': 'constant', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '5', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_X = -50;
int START_Y = getHeight() + 60;
boolean isDiagonal = false;
boolean isUpRight = true;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = -50;', 'startYPosition': 'int START_Y = getHeight() + 60;', 'isDiagonal': 'boolean isDiagonal = false;', 'isUpRight': 'boolean isUpRight = true;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 11;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.ORANGE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '11', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': 'add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_X = 50;
int START_Y = 50;
boolean isDiagonal = false;
boolean isUpRight = false;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = 50;', 'startYPosition': 'int START_Y = 50;', 'isDiagonal': 'boolean isDiagonal = false;', 'isUpRight': 'boolean isUpRight = false;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': 'add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the shape and initialize parameters
        int START_X = 100;
int START_Y = -50;
int NUM_ROWS = 16;
int NUM_BRICKS_BASE = 16;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;
boolean isUpsideDown = false;
boolean isRightTriangle = true;
String input = ""16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.ORANGE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'shape': 'rightTriangle', 'numBricksBase': '16', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '0', 'rowSeparation': '0', 'isUpsideDown': 'false', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = 1;
int START_X = 100;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.GREEN);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 5;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 40;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 10;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '10', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize structure parameters
        int START_X = 100;
int START_Y = 50;
int NUM_ROWS = 7;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 5;
int ROW_SEP = 5;
int HORIZONTAL_OFFSET = -20;
int HOLE_PROBABILITY = 2;
boolean isUpsideDown = true;
String input = ""7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.ORANGE);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'numBricksBase': '7', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '5', 'rowSeparation': '5', 'horizontalOffset': '-20', 'holeProbability': '2', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 12;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '12', 'brickWidth': '80', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 300);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
int ROGUE_BRICK_INDEX = 1;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLUE);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '300', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 10;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 1;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 7;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 20;
int BRICK_SEP_FIRST_ROW = 5;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = 50;
int START_Y_FIRST_ROW = 100;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLUE);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 4;
int BRICK_WIDTH_SECOND_ROW = 40;
int BRICK_HEIGHT_SECOND_ROW = 20;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = 1;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLUE);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 7;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '20', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 5;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = 50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 100;', 'brickColor': 'Color.BLUE', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 4;', 'brickWidthSecondRow': '40', 'brickHeightSecondRow': '20', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = 1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Determine the shape and initialize parameters
        int START_X = 50;
int START_Y = 50;
int NUM_ROWS = 10;
int NUM_BRICKS_BASE = 16;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
int ROW_SEP = 0;
boolean isUpsideDown = true;
boolean isRightTriangle = false;
String input = ""16, 15, 14, 13, 12, 11, 10, 9, 8, 7"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.MAGENTA);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'shape': 'trapezoid', 'numBricksBase': '16', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '10', 'rowSeparation': '0', 'isUpsideDown': 'true', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 50;;
int START_Y = int START_Y = 50;;
int NUM_ROWS = 6;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = -20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.YELLOW);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'numBricksBase': '6', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': '5', 'rowSeparation': '10', 'horizontalOffset': '-20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 6;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 5;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = -50;
int START_Y = 100;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.ORANGE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 6;', 'offset': 'int OFFSET = 20;', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 5;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 7;
int BRICK_WIDTH_FIRST_ROW = 20;
int BRICK_HEIGHT_FIRST_ROW = 40;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = -100;
int START_Y_FIRST_ROW = -50;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 6;
int BRICK_WIDTH_SECOND_ROW = 40;
int BRICK_HEIGHT_SECOND_ROW = 30;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = 1;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 250;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 7;', 'brickWidthFirstRow': '20', 'brickHeightFirstRow': '40', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = -100;', 'startYFirstRow': 'int START_Y_FIRST_ROW = -50;', 'brickColor': 'Color.BLACK', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 6;', 'brickWidthSecondRow': '40', 'brickHeightSecondRow': '30', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = 1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 250;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 100;;
int START_Y = int START_Y = 100;;
int NUM_ROWS = 7;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6, 7"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.ORANGE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'numBricksBase': '7', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '0', 'horizontalOffset': '20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = 1;
int START_X = 50;
int START_Y = 100;
boolean isDiagonal = false;
boolean isUpRight = false;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 1;', 'startXPosition': 'int START_X = 50;', 'startYPosition': 'int START_Y = 100;', 'isDiagonal': 'boolean isDiagonal = false;', 'isUpRight': 'boolean isUpRight = false;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 600);

        // Determine the shape and initialize parameters
        int START_X = 50;
int START_Y = -50;
int NUM_ROWS = 15;
int NUM_BRICKS_BASE = 15;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROW_SEP = 0;
boolean isUpsideDown = false;
boolean isRightTriangle = true;
String input = ""15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.YELLOW);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '600', 'shape': 'rightTriangle', 'numBricksBase': '15', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '5', 'rowSeparation': '0', 'isUpsideDown': 'false', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = -50;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 12;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '12', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = 1;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.ORANGE);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 1;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 4;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 8;;
int OFFSET = int OFFSET = -20;;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = -50;
int START_Y = 50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'numRows': 'int NUM_ROWS = 4;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 8;', 'offset': 'int OFFSET = -20;', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = 1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = -50;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = 100;
int START_Y = 50;
int NUM_COLUMNS = 5;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
boolean isUpsideDown = false;
boolean isColumn = true;
String input = ""5, 5, 5, 5, 5"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.MAGENTA);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'structure': 'column', 'numColumns': '5', 'numBricksPerColumn': 'constant', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': '0', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = 100;
int START_Y = 100;
int NUM_COLUMNS = 6;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
boolean isUpsideDown = false;
boolean isColumn = false;
String input = ""6, 6, 6, 6, 6, 6"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.ORANGE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'structure': 'diagonal', 'numColumns': '6', 'numBricksPerColumn': 'constant', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '0', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = -50;;
int START_Y = int START_Y = -50;;
int NUM_ROWS = 5;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'numBricksBase': '5', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '0', 'rowSeparation': '0', 'horizontalOffset': '20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize structure parameters
        int START_X = -50;
int START_Y = 50;
int NUM_ROWS = 8;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 2;
boolean isUpsideDown = true;
String input = ""8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(true);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.YELLOW);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'numBricksBase': '8', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '10', 'horizontalOffset': '20', 'holeProbability': '2', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 3;
int BRICK_WIDTH_FIRST_ROW = 20;
int BRICK_HEIGHT_FIRST_ROW = 20;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = 50;
int START_Y_FIRST_ROW = 100;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.YELLOW);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 8;
int BRICK_WIDTH_SECOND_ROW = 40;
int BRICK_HEIGHT_SECOND_ROW = 20;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = 1;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 200;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.YELLOW);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 3;', 'brickWidthFirstRow': '20', 'brickHeightFirstRow': '20', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = 50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 100;', 'brickColor': 'Color.YELLOW', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 8;', 'brickWidthSecondRow': '40', 'brickHeightSecondRow': '20', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = 1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 200;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize structure parameters
        int START_X = 100;
int START_Y = 50;
int NUM_ROWS = 5;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 1;
boolean isUpsideDown = true;
String input = ""5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.MAGENTA);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'numBricksBase': '5', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': '10', 'rowSeparation': '0', 'horizontalOffset': '20', 'holeProbability': '1', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '80', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = 2;
int START_X = 50;
int START_Y = getHeight() + 60;
boolean isDiagonal = true;
boolean isUpRight = false;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.BLUE);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 2;', 'startXPosition': 'int START_X = 50;', 'startYPosition': 'int START_Y = getHeight() + 60;', 'isDiagonal': 'boolean isDiagonal = true;', 'isUpRight': 'boolean isUpRight = false;', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 300);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 6;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = 1;
int START_Y = getHeight() / 2;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.ORANGE);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '300', 'numBricks': 'int NUM_BRICKS = 6;', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 1;', 'startYPosition': 'int START_Y = getHeight() / 2;', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;

        // Optionally add centering assist lines
        add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.ORANGE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '40', 'centeringAssistLines': 'add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(800,400)
        // Create a rectangle with the specified position 
        int x = 150; int y = 150;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 50, 100);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{OffCanvas}', 'OffCanvas': 'setSize(800,400)', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 150; int y = 150;', 'rectangleOrientation': '{StandingRectangle}', 'standingRectangleSize': 'GRect rect = new GRect(x, y, 50, 100);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 7;
int BRICK_WIDTH_FIRST_ROW = 20;
int BRICK_HEIGHT_FIRST_ROW = 20;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = 1;
int START_X_FIRST_ROW = -100;
int START_Y_FIRST_ROW = 50;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 6;
int BRICK_WIDTH_SECOND_ROW = 40;
int BRICK_HEIGHT_SECOND_ROW = 20;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = -1;
int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 7;', 'brickWidthFirstRow': '20', 'brickHeightFirstRow': '20', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = 1;', 'startXFirstRow': 'int START_X_FIRST_ROW = -100;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 50;', 'brickColor': 'Color.BLACK', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 6;', 'brickWidthSecondRow': '40', 'brickHeightSecondRow': '20', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = -1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROGUE_BRICK_INDEX = 2;
int START_X = 50;
int START_Y = getHeight() + 60;
boolean isDiagonal = true;
boolean isUpRight = true;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.GREEN);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 5;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 2;', 'startXPosition': 'int START_X = 50;', 'startYPosition': 'int START_Y = getHeight() + 60;', 'isDiagonal': 'boolean isDiagonal = true;', 'isUpRight': 'boolean isUpRight = true;', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 20;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.MAGENTA);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 100;;
int START_Y = int START_Y = -50;;
int NUM_ROWS = 5;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = -20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'numBricksBase': '5', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '0', 'horizontalOffset': '-20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '80', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = -50;
int START_Y = 100;
int NUM_COLUMNS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
boolean isUpsideDown = true;
boolean isColumn = false;
String input = ""3, 3, 3"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.MAGENTA);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'structure': 'diagonal', 'numColumns': '3', 'numBricksPerColumn': 'constant', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '10', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 6;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int OFFSET = int OFFSET = -20;;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = 2;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = -50;
int START_Y = 100;
boolean isRogueRow = true;
boolean isRogueDiagonal = true;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.ORANGE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 6;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'offset': 'int OFFSET = -20;', 'brickWidth': '20', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 2;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(800,400+60)
        // Create a rectangle with the specified position 
        int x = 100; int y = 100;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 50, 100);
        // Add color, optional 
        rect.setFilled(true); rect.setColor(Color.GREEN);

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(800,400+60)', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 100; int y = 100;', 'rectangleOrientation': '{StandingRectangle}', 'standingRectangleSize': 'GRect rect = new GRect(x, y, 50, 100);', 'rectangleColor': 'rect.setFilled(true); rect.setColor(Color.GREEN);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 40;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 10;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '10', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400+60);
        // Create a rectangle with the specified position 
        int x = -50; int y = -50;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 100, 50);
        // Add color, optional 
        rect.setFilled(true); rect.setColor(Color.BLUE);

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(600,400+60);', 'initialPointLocation': '{OffCanvasPositions}', 'offCanvasPosition': 'int x = -50; int y = -50;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 100, 50);', 'rectangleColor': 'rect.setFilled(true); rect.setColor(Color.BLUE);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.ORANGE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': 'add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 3;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 6;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 10;
int ROGUE_ROW_INDEX = 2;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = -50;
int START_Y = 100;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'numRows': 'int NUM_ROWS = 3;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 6;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 10;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 2;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(true);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 7;
int BRICK_WIDTH_FIRST_ROW = 30;
int BRICK_HEIGHT_FIRST_ROW = 30;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = 1;
int START_X_FIRST_ROW = 100;
int START_Y_FIRST_ROW = 50;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 8;
int BRICK_WIDTH_SECOND_ROW = 30;
int BRICK_HEIGHT_SECOND_ROW = 20;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = 2;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 7;', 'brickWidthFirstRow': '30', 'brickHeightFirstRow': '30', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = 1;', 'startXFirstRow': 'int START_X_FIRST_ROW = 100;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 50;', 'brickColor': 'Color.BLACK', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 8;', 'brickWidthSecondRow': '30', 'brickHeightSecondRow': '20', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = 2;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = -50;
int START_Y = 100;
int NUM_COLUMNS = 3;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
boolean isUpsideDown = true;
boolean isColumn = true;
String input = ""1, 2, 3"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'structure': 'column', 'numColumns': '3', 'numBricksPerColumn': 'varying', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': '10', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 8;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 6;;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = 1;
int ROGUE_DIAGONAL_INDEX = 1;
int START_X = 100;
int START_Y = 50;
boolean isRogueRow = true;
boolean isRogueDiagonal = false;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.YELLOW);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 8;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 6;', 'brickWidth': '30', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '80', 'brickHeight': '20', 'centeringAssistLines': 'add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(800,400+60)
        // Create a rectangle with the specified position 
        int x = -75; int y = -75;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 75, 150);
        // Add color, optional 
        rect.setFilled(true); rect.setColor(Color.MAGENTA);

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(800,400+60)', 'initialPointLocation': '{OffCanvasPositions}', 'offCanvasPosition': 'int x = -75; int y = -75;', 'rectangleOrientation': '{StandingRectangle}', 'standingRectangleSize': 'GRect rect = new GRect(x, y, 75, 150);', 'rectangleColor': 'rect.setFilled(true); rect.setColor(Color.MAGENTA);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Initialize structure parameters
        int START_X = 100;
int START_Y = 50;
int NUM_ROWS = 5;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 2;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.BLACK);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'numBricksBase': '5', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '5', 'rowSeparation': '10', 'horizontalOffset': '20', 'holeProbability': '2', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Determine the structure and initialize parameters
        int START_X = -50;
int START_Y = 50;
int NUM_COLUMNS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 5;
boolean isUpsideDown = false;
boolean isColumn = false;
String input = ""3, 3, 3"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'structure': 'diagonal', 'numColumns': '3', 'numBricksPerColumn': 'constant', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '5', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Determine the structure and initialize parameters
        int START_X = -50;
int START_Y = 100;
int NUM_COLUMNS = 7;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 10;
boolean isUpsideDown = false;
boolean isColumn = true;
String input = ""7, 7, 7, 7, 7, 7, 7"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GREEN);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'structure': 'column', 'numColumns': '7', 'numBricksPerColumn': 'constant', 'brickWidth': '30', 'brickHeight': '30', 'brickSeparation': '10', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = 2;
int START_X = 100;
int START_Y = 100;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 2;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 5;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int OFFSET = int OFFSET = -20;;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 10;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = 1;
int START_X = -50;
int START_Y = 50;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.MAGENTA);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 5;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'offset': 'int OFFSET = -20;', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 10;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = 50;
int START_Y = 100;
int NUM_COLUMNS = 4;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
boolean isUpsideDown = false;
boolean isColumn = false;
String input = ""4, 4, 4, 4"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 100;', 'structure': 'diagonal', 'numColumns': '4', 'numBricksPerColumn': 'constant', 'brickWidth': '20', 'brickHeight': '40', 'brickSeparation': '0', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 6;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 3;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = 1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 100;
int START_Y = -50;
boolean isRogueRow = true;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 6;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 3;', 'offset': 'int OFFSET = 20;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROGUE_BRICK_INDEX = -1;
int START_X = 50;
int START_Y = getHeight() + 60;
boolean isDiagonal = false;
boolean isUpRight = false;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 10;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = 50;', 'startYPosition': 'int START_Y = getHeight() + 60;', 'isDiagonal': 'boolean isDiagonal = false;', 'isUpRight': 'boolean isUpRight = false;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(800,400+60)
        // Create a rectangle with the specified position 
        int x = 100; int y = 100;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 100, 50);
        // Add color, optional 
        rect.setFilled(true); rect.setColor(Color.RED);

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(800,400+60)', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 100; int y = 100;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 100, 50);', 'rectangleColor': 'rect.setFilled(true); rect.setColor(Color.RED);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 6;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 4;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = 1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 100;
int START_Y = 100;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.ORANGE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 6;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 4;', 'offset': 'int OFFSET = 20;', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                brick.setColor(Color.BLUE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 100;;
int START_Y = int START_Y = -50;;
int NUM_ROWS = 7;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 5;
int HORIZONTAL_OFFSET = -20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6, 7"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'numBricksBase': '7', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '0', 'rowSeparation': '5', 'horizontalOffset': '-20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 11;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '11', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 8;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 5;
int ROGUE_ROW_INDEX = 2;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 100;
int START_Y = -50;
boolean isRogueRow = true;
boolean isRogueDiagonal = false;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 8;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'brickWidth': '20', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 5;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 2;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '80', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 5;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 6;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 50;
int START_Y = 50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.MAGENTA);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 5;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 6;', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 10;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 8;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = -50;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.MAGENTA);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 8;', 'offset': 'int OFFSET = 20;', 'brickWidth': '20', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 300);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 4;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = 1;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '300', 'numBricks': 'int NUM_BRICKS = 4;', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 1;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 3;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 5;;
int OFFSET = int OFFSET = -20;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = -50;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.ORANGE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 3;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 5;', 'offset': 'int OFFSET = -20;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 10;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 12;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '12', 'brickWidth': '80', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 11;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '11', 'brickWidth': '80', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_X = -50;
int START_Y = -100;
boolean isDiagonal = true;
boolean isUpRight = true;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.MAGENTA);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = -50;', 'startYPosition': 'int START_Y = -100;', 'isDiagonal': 'boolean isDiagonal = true;', 'isUpRight': 'boolean isUpRight = true;', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '80', 'brickHeight': '20', 'centeringAssistLines': 'add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Initialize brick parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROGUE_BRICK_INDEX = -1;
int START_X = -50;
int START_Y = getHeight() - 20;
boolean isDiagonal = true;
boolean isUpRight = true;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 10;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = -50;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'isDiagonal': 'boolean isDiagonal = true;', 'isUpRight': 'boolean isUpRight = true;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 6;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 4;;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 10;
int ROGUE_ROW_INDEX = 1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 100;
int START_Y = 100;
boolean isRogueRow = true;
boolean isRogueDiagonal = true;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 6;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 4;', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 10;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '80', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize structure parameters
        int START_X = 100;
int START_Y = -50;
int NUM_ROWS = 8;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 2;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6, 7, 8"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.MAGENTA);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'numBricksBase': '8', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '5', 'rowSeparation': '10', 'horizontalOffset': '20', 'holeProbability': '2', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 11;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '11', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': 'add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 12;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                brick.setColor(Color.BLUE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '12', 'brickWidth': '80', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 40;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 10;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '10', 'brickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize brick parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_X = 50;
int START_Y = 50;
boolean isDiagonal = false;
boolean isUpRight = false;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.ORANGE);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = 50;', 'startYPosition': 'int START_Y = 50;', 'isDiagonal': 'boolean isDiagonal = false;', 'isUpRight': 'boolean isUpRight = false;', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_Y = 40;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = 40;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 3;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 40;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = 1;
int START_X_FIRST_ROW = 50;
int START_Y_FIRST_ROW = 50;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GREEN);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 6;
int BRICK_WIDTH_SECOND_ROW = 30;
int BRICK_HEIGHT_SECOND_ROW = 20;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = 1;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GREEN);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 3;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '40', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = 1;', 'startXFirstRow': 'int START_X_FIRST_ROW = 50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 50;', 'brickColor': 'Color.GREEN', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 6;', 'brickWidthSecondRow': '30', 'brickHeightSecondRow': '20', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = 1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 3;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 6;;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 5;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = 1;
int START_X = 100;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 3;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 6;', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 10;', 'rowSeparation': 'int ROW_SEP = 5;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 12;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.ORANGE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '12', 'brickWidth': '40', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400+60);
        // Create a rectangle with the specified position 
        int x = 150; int y = 150;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 200, 100);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(600,400+60);', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 150; int y = 150;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 200, 100);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 8;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 6;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = 1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 100;
int START_Y = 50;
boolean isRogueRow = true;
boolean isRogueDiagonal = true;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 8;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 6;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 4;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 8;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
int ROW_SEP = 5;
int ROGUE_ROW_INDEX = 2;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 100;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 4;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 8;', 'offset': 'int OFFSET = 20;', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 10;', 'rowSeparation': 'int ROW_SEP = 5;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 2;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = 1;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.YELLOW);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 1;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 12;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '12', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': 'add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize structure parameters
        int START_X = -50;
int START_Y = 100;
int NUM_ROWS = 4;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 3;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(true);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.GRAY);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'numBricksBase': '4', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '0', 'horizontalOffset': '20', 'holeProbability': '3', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 10;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;

        // Optionally add centering assist lines
        add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLUE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '10', 'brickWidth': '40', 'brickHeight': '40', 'centeringAssistLines': 'add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 8;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 10;
int ROW_SEP = 10;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = 1;
int START_X = -50;
int START_Y = 50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 8;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'brickWidth': '20', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 10;', 'rowSeparation': 'int ROW_SEP = 10;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.YELLOW);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 10;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.MAGENTA);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 40;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 10;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLUE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '10', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 40;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '80', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 6;
int BRICK_WIDTH_FIRST_ROW = 20;
int BRICK_HEIGHT_FIRST_ROW = 40;
int BRICK_SEP_FIRST_ROW = 5;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = 50;
int START_Y_FIRST_ROW = -150;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 7;
int BRICK_WIDTH_SECOND_ROW = 30;
int BRICK_HEIGHT_SECOND_ROW = 30;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = 2;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 6;', 'brickWidthFirstRow': '20', 'brickHeightFirstRow': '40', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 5;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = 50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = -150;', 'brickColor': 'Color.BLACK', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 7;', 'brickWidthSecondRow': '30', 'brickHeightSecondRow': '30', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = 2;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '80', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(true);'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400,400+60)
        // Create a rectangle with the specified position 
        int x = 50; int y = 50;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 100, 50);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(400,400+60)', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 50; int y = 50;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 100, 50);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Determine the shape and initialize parameters
        int START_X = 100;
int START_Y = -50;
int NUM_ROWS = 10;
int NUM_BRICKS_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROW_SEP = 0;
boolean isUpsideDown = false;
boolean isRightTriangle = false;
String input = ""10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.MAGENTA);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'shape': 'trapezoid', 'numBricksBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '5', 'rowSeparation': '0', 'isUpsideDown': 'false', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 20;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(true);'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400+60);
        // Create a rectangle with the specified position 
        int x = 300; int y = 100;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 75, 150);
        // Add color, optional 
        rect.setFilled(true); rect.setColor(Color.MAGENTA);

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(600,400+60);', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 300; int y = 100;', 'rectangleOrientation': '{StandingRectangle}', 'standingRectangleSize': 'GRect rect = new GRect(x, y, 75, 150);', 'rectangleColor': 'rect.setFilled(true); rect.setColor(Color.MAGENTA);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize structure parameters
        int START_X = -50;
int START_Y = -50;
int NUM_ROWS = 8;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 2;
boolean isUpsideDown = true;
String input = ""8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.BLUE);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'numBricksBase': '8', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': '10', 'rowSeparation': '10', 'horizontalOffset': '20', 'holeProbability': '2', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the shape and initialize parameters
        int START_X = 100;
int START_Y = 100;
int NUM_ROWS = 10;
int NUM_BRICKS_BASE = 16;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 5;
int ROW_SEP = 5;
boolean isUpsideDown = false;
boolean isRightTriangle = false;
String input = ""10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'shape': 'trapezoid', 'numBricksBase': '16', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '5', 'rowSeparation': '5', 'isUpsideDown': 'false', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 4;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 5;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = -50;
int START_Y = -50;
boolean isRogueRow = true;
boolean isRogueDiagonal = false;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numRows': 'int NUM_ROWS = 4;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 5;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 6;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 30;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = 2;
int START_X_FIRST_ROW = 100;
int START_Y_FIRST_ROW = -150;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 7;
int BRICK_WIDTH_SECOND_ROW = 30;
int BRICK_HEIGHT_SECOND_ROW = 40;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = -1;
int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 6;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '30', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = 2;', 'startXFirstRow': 'int START_X_FIRST_ROW = 100;', 'startYFirstRow': 'int START_Y_FIRST_ROW = -150;', 'brickColor': 'Color.GRAY', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 7;', 'brickWidthSecondRow': '30', 'brickHeightSecondRow': '40', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = -1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = 50;
int START_Y = 50;
int NUM_COLUMNS = 4;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
boolean isUpsideDown = false;
boolean isColumn = true;
String input = ""4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.ORANGE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'structure': 'column', 'numColumns': '4', 'numBricksPerColumn': 'varying', 'brickWidth': '20', 'brickHeight': '40', 'brickSeparation': '0', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.GREEN);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 200);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '200', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 300);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 6;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_Y = getHeight() / 2;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.MAGENTA);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '300', 'numBricks': 'int NUM_BRICKS = 6;', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = getHeight() / 2;', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': 'add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 100;;
int START_Y = int START_Y = 100;;
int NUM_ROWS = 5;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'numBricksBase': '5', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '0', 'rowSeparation': '0', 'horizontalOffset': '20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400+60);
        // Create a rectangle with the specified position 
        int x = 50; int y = 50;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 100, 50);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(600,400+60);', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 50; int y = 50;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 100, 50);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 8;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 5;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
int ROW_SEP = 5;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = 2;
int START_X = 100;
int START_Y = 50;
boolean isRogueRow = true;
boolean isRogueDiagonal = false;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.GREEN);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 8;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 5;', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 10;', 'rowSeparation': 'int ROW_SEP = 5;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 2;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 8;
int BRICK_WIDTH_FIRST_ROW = 20;
int BRICK_HEIGHT_FIRST_ROW = 40;
int BRICK_SEP_FIRST_ROW = 10;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = -50;
int START_Y_FIRST_ROW = 50;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.MAGENTA);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 7;
int BRICK_WIDTH_SECOND_ROW = 30;
int BRICK_HEIGHT_SECOND_ROW = 20;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = 2;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.MAGENTA);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 8;', 'brickWidthFirstRow': '20', 'brickHeightFirstRow': '40', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 10;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = -50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 50;', 'brickColor': 'Color.MAGENTA', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 7;', 'brickWidthSecondRow': '30', 'brickHeightSecondRow': '20', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = 2;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400+60);
        // Create a rectangle with the specified position 
        int x = 50; int y = 50;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 100, 50);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(600,400+60);', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 50; int y = 50;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 100, 50);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 8;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 20;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = 50;
int START_Y_FIRST_ROW = -100;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 6;
int BRICK_WIDTH_SECOND_ROW = 30;
int BRICK_HEIGHT_SECOND_ROW = 20;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = 1;
int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 8;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '20', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = 50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = -100;', 'brickColor': 'Color.BLACK', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 6;', 'brickWidthSecondRow': '30', 'brickHeightSecondRow': '20', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = 1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 12;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '12', 'brickWidth': '80', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Initialize brick parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_X = 50;
int START_Y = 50;
boolean isDiagonal = false;
boolean isUpRight = true;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = 50;', 'startYPosition': 'int START_Y = 50;', 'isDiagonal': 'boolean isDiagonal = false;', 'isUpRight': 'boolean isUpRight = true;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 20;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 5;
int ROGUE_BRICK_INDEX = -1;
int START_Y = 40;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.ORANGE);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '20', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 5;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = 40;', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize structure parameters
        int START_X = 50;
int START_Y = 50;
int NUM_ROWS = 3;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = -20;
int HOLE_PROBABILITY = 3;
boolean isUpsideDown = false;
String input = ""1, 2, 3"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.GREEN);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'numBricksBase': '3', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': '10', 'rowSeparation': '10', 'horizontalOffset': '-20', 'holeProbability': '3', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 10;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '10', 'brickWidth': '40', 'brickHeight': '40', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 5;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = 1;
int START_X = -50;
int START_Y = 50;
boolean isRogueRow = true;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'numRows': 'int NUM_ROWS = 5;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'offset': 'int OFFSET = 20;', 'brickWidth': '20', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 6;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 20;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = 50;
int START_Y_FIRST_ROW = 50;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 7;
int BRICK_WIDTH_SECOND_ROW = 30;
int BRICK_HEIGHT_SECOND_ROW = 40;
int BRICK_SEP_SECOND_ROW = 5;
int ROGUE_BRICK_INDEX_SECOND_ROW = 1;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 6;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '20', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = 50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 50;', 'brickColor': 'Color.BLACK', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 7;', 'brickWidthSecondRow': '30', 'brickHeightSecondRow': '40', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 5;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = 1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 11;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.YELLOW);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '11', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the shape and initialize parameters
        int START_X = 50;
int START_Y = 50;
int NUM_ROWS = 10;
int NUM_BRICKS_BASE = 15;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;
boolean isUpsideDown = true;
boolean isRightTriangle = false;
String input = ""15, 14, 13, 12, 11, 10, 9, 8, 7, 6"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'shape': 'trapezoid', 'numBricksBase': '15', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '0', 'rowSeparation': '0', 'isUpsideDown': 'true', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 4;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = 1;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLUE);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 4;', 'brickWidth': '20', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 1;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 20;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                brick.setColor(Color.ORANGE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = 100;
int START_Y = 100;
int NUM_COLUMNS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
boolean isUpsideDown = true;
boolean isColumn = true;
String input = ""1, 2, 3"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'structure': 'column', 'numColumns': '3', 'numBricksPerColumn': 'varying', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '10', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 4;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 5;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = 1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 100;
int START_Y = 50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 4;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 5;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 8;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 100;
int START_Y = -50;
boolean isRogueRow = true;
boolean isRogueDiagonal = true;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLUE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 8;', 'offset': 'int OFFSET = 20;', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 11;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;

        // Optionally add centering assist lines
        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '11', 'brickWidth': '40', 'brickHeight': '40', 'centeringAssistLines': 'add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Determine the structure and initialize parameters
        int START_X = 50;
int START_Y = -50;
int NUM_COLUMNS = 4;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
boolean isUpsideDown = false;
boolean isColumn = true;
String input = ""4, 4, 4, 4"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = -50;', 'structure': 'column', 'numColumns': '4', 'numBricksPerColumn': 'constant', 'brickWidth': '20', 'brickHeight': '40', 'brickSeparation': '0', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 100;;
int START_Y = int START_Y = 50;;
int NUM_ROWS = 6;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 5;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = true;
String input = ""6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'numBricksBase': '6', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '5', 'horizontalOffset': '20', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROGUE_BRICK_INDEX = -1;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 5;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400+60);
        // Create a rectangle with the specified position 
        int x = 150; int y = 150;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 150, 75);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(600,400+60);', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 150; int y = 150;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 150, 75);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 11;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLUE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '11', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Determine the shape and initialize parameters
        int START_X = 100;
int START_Y = -50;
int NUM_ROWS = 16;
int NUM_BRICKS_BASE = 16;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 10;
boolean isUpsideDown = false;
boolean isRightTriangle = true;
String input = ""16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLUE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'shape': 'rightTriangle', 'numBricksBase': '16', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '0', 'rowSeparation': '10', 'isUpsideDown': 'false', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 11;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '11', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.GRAY);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 10;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.GRAY);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROGUE_BRICK_INDEX = -1;
int START_X = 50;
int START_Y = getHeight() + 60;
boolean isDiagonal = false;
boolean isUpRight = false;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 10;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = 50;', 'startYPosition': 'int START_Y = getHeight() + 60;', 'isDiagonal': 'boolean isDiagonal = false;', 'isUpRight': 'boolean isUpRight = false;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Determine the shape and initialize parameters
        int START_X = -50;
int START_Y = -50;
int NUM_ROWS = 13;
int NUM_BRICKS_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 0;
boolean isUpsideDown = false;
boolean isRightTriangle = true;
String input = ""13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'shape': 'rightTriangle', 'numBricksBase': '13', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '0', 'rowSeparation': '0', 'isUpsideDown': 'false', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 4;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 5;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 50;
int START_Y = 50;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GREEN);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 4;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'offset': 'int OFFSET = 20;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 5;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Initialize structure parameters
        int START_X = -50;
int START_Y = 50;
int NUM_ROWS = 6;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 5;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = -20;
int HOLE_PROBABILITY = 2;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.BLACK);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'numBricksBase': '6', 'brickWidth': '30', 'brickHeight': '30', 'brickSeparation': '5', 'rowSeparation': '10', 'horizontalOffset': '-20', 'holeProbability': '2', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters
        int NUM_BRICKS = 6;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 10;
int ROGUE_BRICK_INDEX = 1;
int START_X = 50;
int START_Y = getHeight() + 60;
boolean isDiagonal = true;
boolean isUpRight = false;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 6;', 'brickWidth': '20', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 10;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 1;', 'startXPosition': 'int START_X = 50;', 'startYPosition': 'int START_Y = getHeight() + 60;', 'isDiagonal': 'boolean isDiagonal = true;', 'isUpRight': 'boolean isUpRight = false;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400);
        // Create a rectangle with the specified position 
        int x = 200; int y = 50;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 200, 100);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{OffCanvas}', 'OffCanvas': 'setSize(600,400);', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 200; int y = 50;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 200, 100);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROGUE_BRICK_INDEX = 2;
int START_Y = 40;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLUE);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 5;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 2;', 'startYPosition': 'int START_Y = 40;', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Determine the structure and initialize parameters
        int START_X = -50;
int START_Y = 50;
int NUM_COLUMNS = 4;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
boolean isUpsideDown = false;
boolean isColumn = true;
String input = ""4, 4, 4, 4"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'structure': 'column', 'numColumns': '4', 'numBricksPerColumn': 'constant', 'brickWidth': '20', 'brickHeight': '40', 'brickSeparation': '0', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 8;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 10;
int ROGUE_ROW_INDEX = 2;
int ROGUE_DIAGONAL_INDEX = 1;
int START_X = -50;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.YELLOW);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 8;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 10;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 2;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 5;;
int OFFSET = int OFFSET = -20;;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 100;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.MAGENTA);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 5;', 'offset': 'int OFFSET = -20;', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 10;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 3;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 20;
int BRICK_SEP_FIRST_ROW = 5;
int ROGUE_BRICK_INDEX_FIRST_ROW = 2;
int START_X_FIRST_ROW = 50;
int START_Y_FIRST_ROW = -100;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 7;
int BRICK_WIDTH_SECOND_ROW = 30;
int BRICK_HEIGHT_SECOND_ROW = 20;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = -1;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 3;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '20', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 5;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = 2;', 'startXFirstRow': 'int START_X_FIRST_ROW = 50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = -100;', 'brickColor': 'Color.BLACK', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 7;', 'brickWidthSecondRow': '30', 'brickHeightSecondRow': '20', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = -1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 8;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 6;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 100;
int START_Y = 100;
boolean isRogueRow = true;
boolean isRogueDiagonal = true;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.GREEN);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 8;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 6;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(800,400)
        // Create a rectangle with the specified position 
        int x = 50; int y = 50;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 75, 150);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{OffCanvas}', 'OffCanvas': 'setSize(800,400)', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 50; int y = 50;', 'rectangleOrientation': '{StandingRectangle}', 'standingRectangleSize': 'GRect rect = new GRect(x, y, 75, 150);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.YELLOW);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '80', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400+60);
        // Create a rectangle with the specified position 
        int x = 50; int y = 50;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 75, 150);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(600,400+60);', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 50; int y = 50;', 'rectangleOrientation': '{StandingRectangle}', 'standingRectangleSize': 'GRect rect = new GRect(x, y, 75, 150);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.YELLOW);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 200);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 6;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
int ROGUE_BRICK_INDEX = 1;
int START_Y = -40;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GREEN);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '200', 'numBricks': 'int NUM_BRICKS = 6;', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 10;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 1;', 'startYPosition': 'int START_Y = -40;', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 6;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 8;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = -50;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 6;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 8;', 'offset': 'int OFFSET = 20;', 'brickWidth': '20', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 5;
int BRICK_WIDTH_FIRST_ROW = 30;
int BRICK_HEIGHT_FIRST_ROW = 40;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = -50;
int START_Y_FIRST_ROW = -50;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.MAGENTA);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 6;
int BRICK_WIDTH_SECOND_ROW = 30;
int BRICK_HEIGHT_SECOND_ROW = 40;
int BRICK_SEP_SECOND_ROW = 10;
int ROGUE_BRICK_INDEX_SECOND_ROW = 2;
int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.MAGENTA);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 5;', 'brickWidthFirstRow': '30', 'brickHeightFirstRow': '40', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = -50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = -50;', 'brickColor': 'Color.MAGENTA', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 6;', 'brickWidthSecondRow': '30', 'brickHeightSecondRow': '40', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 10;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = 2;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 40;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.GRAY);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '80', 'brickHeight': '40', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 5;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 40;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = 50;
int START_Y_FIRST_ROW = 50;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 5;
int BRICK_WIDTH_SECOND_ROW = 30;
int BRICK_HEIGHT_SECOND_ROW = 20;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = 1;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 5;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '40', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = 50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 50;', 'brickColor': 'Color.BLACK', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 5;', 'brickWidthSecondRow': '30', 'brickHeightSecondRow': '20', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = 1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 3;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 6;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 5;
int ROGUE_ROW_INDEX = 1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 50;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 3;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 6;', 'offset': 'int OFFSET = 20;', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 5;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '80', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters
        int NUM_BRICKS = 6;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_X = -50;
int START_Y = getHeight() + 60;
boolean isDiagonal = false;
boolean isUpRight = false;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 6;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = -50;', 'startYPosition': 'int START_Y = getHeight() + 60;', 'isDiagonal': 'boolean isDiagonal = false;', 'isUpRight': 'boolean isUpRight = false;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 11;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.YELLOW);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '11', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 50;;
int START_Y = int START_Y = 100;;
int NUM_ROWS = 7;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = -20;
boolean isUpsideDown = true;
String input = ""7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 100;', 'numBricksBase': '7', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': '0', 'rowSeparation': '0', 'horizontalOffset': '-20', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 300);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_Y = getHeight() / 2;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.YELLOW);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '300', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = getHeight() / 2;', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 4;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 10;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = -50;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLUE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 4;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'offset': 'int OFFSET = 20;', 'brickWidth': '20', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 10;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize structure parameters
        int START_X = -50;
int START_Y = 100;
int NUM_ROWS = 5;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 5;
int HORIZONTAL_OFFSET = -20;
int HOLE_PROBABILITY = 2;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(true);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.GREEN);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'numBricksBase': '5', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': '0', 'rowSeparation': '5', 'horizontalOffset': '-20', 'holeProbability': '2', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 10;
int ROGUE_BRICK_INDEX = -1;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.YELLOW);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 10;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 10;
int NUM_ROWS = 10;
int BRICK_WIDTH = 60;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '60', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize structure parameters
        int START_X = 50;
int START_Y = 100;
int NUM_ROWS = 6;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 10;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 3;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.ORANGE);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 100;', 'numBricksBase': '6', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '10', 'rowSeparation': '10', 'horizontalOffset': '20', 'holeProbability': '3', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 7;
int NUM_ROWS = 40;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 10;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '80', 'brickHeight': '10', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Determine the shape and initialize parameters
        int START_X = 50;
int START_Y = 100;
int NUM_ROWS = 13;
int NUM_BRICKS_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;
boolean isUpsideDown = true;
boolean isRightTriangle = true;
String input = ""1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GREEN);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'shape': 'rightTriangle', 'numBricksBase': '13', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '0', 'rowSeparation': '0', 'isUpsideDown': 'true', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 100;', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400);
        // Create a rectangle with the specified position 
        int x = 150; int y = 150;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 200, 100);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{OffCanvas}', 'OffCanvas': 'setSize(600,400);', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 150; int y = 150;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 200, 100);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Determine the structure and initialize parameters
        int START_X = -50;
int START_Y = 100;
int NUM_COLUMNS = 5;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
boolean isUpsideDown = false;
boolean isColumn = true;
String input = ""5, 5, 5, 5, 5"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'structure': 'column', 'numColumns': '5', 'numBricksPerColumn': 'constant', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': '5', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 100;;
int START_Y = int START_Y = -50;;
int NUM_ROWS = 6;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = true;
String input = ""6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GREEN);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'numBricksBase': '6', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': '10', 'rowSeparation': '0', 'horizontalOffset': '20', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 200);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 6;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 5;
int ROGUE_BRICK_INDEX = 2;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLUE);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '200', 'numBricks': 'int NUM_BRICKS = 6;', 'brickWidth': '20', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 5;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 2;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.MAGENTA);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 11;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '11', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the shape and initialize parameters
        int START_X = 50;
int START_Y = 50;
int NUM_ROWS = 13;
int NUM_BRICKS_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
boolean isUpsideDown = true;
boolean isRightTriangle = true;
String input = ""1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLUE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'shape': 'rightTriangle', 'numBricksBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '0', 'isUpsideDown': 'true', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = 2;
int START_X = 100;
int START_Y = -100;
boolean isDiagonal = true;
boolean isUpRight = false;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 2;', 'startXPosition': 'int START_X = 100;', 'startYPosition': 'int START_Y = -100;', 'isDiagonal': 'boolean isDiagonal = true;', 'isUpRight': 'boolean isUpRight = false;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 10;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the shape and initialize parameters
        int START_X = -50;
int START_Y = 100;
int NUM_ROWS = 16;
int NUM_BRICKS_BASE = 16;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 0;
boolean isUpsideDown = true;
boolean isRightTriangle = true;
String input = ""1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.YELLOW);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'shape': 'rightTriangle', 'numBricksBase': '16', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '0', 'rowSeparation': '0', 'isUpsideDown': 'true', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 11;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.MAGENTA);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '11', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 3;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 20;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = 50;
int START_Y_FIRST_ROW = -150;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.ORANGE);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 8;
int BRICK_WIDTH_SECOND_ROW = 40;
int BRICK_HEIGHT_SECOND_ROW = 40;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = -1;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 200;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.ORANGE);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 3;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '20', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = 50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = -150;', 'brickColor': 'Color.ORANGE', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 8;', 'brickWidthSecondRow': '40', 'brickHeightSecondRow': '40', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = -1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 200;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 12;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '12', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 50;;
int START_Y = int START_Y = 50;;
int NUM_ROWS = 6;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.ORANGE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'numBricksBase': '6', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '0', 'horizontalOffset': '20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(800,400+60)
        // Create a rectangle with the specified position 
        int x = 75; int y = 75;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 100, 50);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(800,400+60)', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 75; int y = 75;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 100, 50);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
int ROGUE_BRICK_INDEX = -1;
int START_X = 50;
int START_Y = getHeight() - 20;
boolean isDiagonal = false;
boolean isUpRight = true;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '20', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 10;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = 50;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'isDiagonal': 'boolean isDiagonal = false;', 'isUpRight': 'boolean isUpRight = true;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = -50;
int START_Y = 100;
int NUM_COLUMNS = 3;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
boolean isUpsideDown = true;
boolean isColumn = true;
String input = ""3, 3, 3"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.MAGENTA);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'structure': 'column', 'numColumns': '3', 'numBricksPerColumn': 'constant', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': '0', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 12;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                brick.setColor(Color.GRAY);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '12', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize structure parameters
        int START_X = 100;
int START_Y = 100;
int NUM_ROWS = 8;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 10;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 2;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6, 7, 8"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(true);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.BLACK);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'numBricksBase': '8', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '10', 'rowSeparation': '0', 'horizontalOffset': '20', 'holeProbability': '2', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 3;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int OFFSET = int OFFSET = -20;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 5;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = 2;
int START_X = 100;
int START_Y = -50;
boolean isRogueRow = true;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLUE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 3;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'offset': 'int OFFSET = -20;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 10;', 'rowSeparation': 'int ROW_SEP = 5;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 2;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 6;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 40;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = 2;
int START_X_FIRST_ROW = 50;
int START_Y_FIRST_ROW = 150;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GREEN);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 7;
int BRICK_WIDTH_SECOND_ROW = 30;
int BRICK_HEIGHT_SECOND_ROW = 20;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = -1;
int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GREEN);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 6;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '40', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = 2;', 'startXFirstRow': 'int START_X_FIRST_ROW = 50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 150;', 'brickColor': 'Color.GREEN', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 7;', 'brickWidthSecondRow': '30', 'brickHeightSecondRow': '20', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = -1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Determine the shape and initialize parameters
        int START_X = -50;
int START_Y = 100;
int NUM_ROWS = 10;
int NUM_BRICKS_BASE = 14;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 10;
boolean isUpsideDown = true;
boolean isRightTriangle = false;
String input = ""14, 13, 12, 11, 10, 9, 8, 7, 6, 5"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLUE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'shape': 'trapezoid', 'numBricksBase': '14', 'brickWidth': '20', 'brickHeight': '30', 'brickSeparation': '0', 'rowSeparation': '10', 'isUpsideDown': 'true', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize structure parameters
        int START_X = -50;
int START_Y = 100;
int NUM_ROWS = 8;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 10;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 1;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6, 7, 8"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.MAGENTA);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'numBricksBase': '8', 'brickWidth': '30', 'brickHeight': '30', 'brickSeparation': '10', 'rowSeparation': '10', 'horizontalOffset': '20', 'holeProbability': '1', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 6;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.YELLOW);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 6;', 'brickWidth': '20', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = 50;
int START_Y = -50;
int NUM_COLUMNS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
boolean isUpsideDown = false;
boolean isColumn = true;
String input = ""3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = -50;', 'structure': 'column', 'numColumns': '3', 'numBricksPerColumn': 'varying', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '0', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 20;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.YELLOW);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = -50;;
int START_Y = int START_Y = 100;;
int NUM_ROWS = 4;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = -20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'numBricksBase': '4', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '5', 'rowSeparation': '10', 'horizontalOffset': '-20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 6;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = 2;
int START_X = 100;
int START_Y = 100;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.BLUE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 6;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 2;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 5;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 30;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = 1;
int START_X_FIRST_ROW = -100;
int START_Y_FIRST_ROW = 50;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 5;
int BRICK_WIDTH_SECOND_ROW = 30;
int BRICK_HEIGHT_SECOND_ROW = 20;
int BRICK_SEP_SECOND_ROW = 5;
int ROGUE_BRICK_INDEX_SECOND_ROW = -1;
int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 5;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '30', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = 1;', 'startXFirstRow': 'int START_X_FIRST_ROW = -100;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 50;', 'brickColor': 'Color.BLACK', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 5;', 'brickWidthSecondRow': '30', 'brickHeightSecondRow': '20', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 5;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = -1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(true);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Determine the shape and initialize parameters
        int START_X = 50;
int START_Y = 100;
int NUM_ROWS = 10;
int NUM_BRICKS_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 5;
boolean isUpsideDown = false;
boolean isRightTriangle = false;
String input = ""10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'shape': 'trapezoid', 'numBricksBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '5', 'isUpsideDown': 'false', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 100;', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the shape and initialize parameters
        int START_X = 100;
int START_Y = 50;
int NUM_ROWS = 16;
int NUM_BRICKS_BASE = 16;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
boolean isUpsideDown = true;
boolean isRightTriangle = true;
String input = ""1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.MAGENTA);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'shape': 'rightTriangle', 'numBricksBase': '16', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '0', 'isUpsideDown': 'true', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 600);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 4;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = 1;
int START_X = 100;
int START_Y = 100;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.ORANGE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '600', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 4;', 'offset': 'int OFFSET = 20;', 'brickWidth': '30', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Determine the shape and initialize parameters
        int START_X = 50;
int START_Y = 100;
int NUM_ROWS = 16;
int NUM_BRICKS_BASE = 16;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 0;
boolean isUpsideDown = false;
boolean isRightTriangle = true;
String input = ""16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'shape': 'rightTriangle', 'numBricksBase': '16', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '10', 'rowSeparation': '0', 'isUpsideDown': 'false', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 100;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 7;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 40;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = 1;
int START_X_FIRST_ROW = 50;
int START_Y_FIRST_ROW = -100;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 4;
int BRICK_WIDTH_SECOND_ROW = 40;
int BRICK_HEIGHT_SECOND_ROW = 30;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = -1;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 250;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 7;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '40', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = 1;', 'startXFirstRow': 'int START_X_FIRST_ROW = 50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = -100;', 'brickColor': 'Color.BLACK', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 4;', 'brickWidthSecondRow': '40', 'brickHeightSecondRow': '30', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = -1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 250;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize structure parameters
        int START_X = -50;
int START_Y = -50;
int NUM_ROWS = 7;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 3;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6, 7"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(true);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.GRAY);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'numBricksBase': '7', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': '5', 'rowSeparation': '0', 'horizontalOffset': '20', 'holeProbability': '3', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400,400)
        // Create a rectangle with the specified position 
        int x = 75; int y = 75;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 50, 100);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{OffCanvas}', 'OffCanvas': 'setSize(400,400)', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 75; int y = 75;', 'rectangleOrientation': '{StandingRectangle}', 'standingRectangleSize': 'GRect rect = new GRect(x, y, 50, 100);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 12;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.GRAY);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '12', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 6;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = 1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 100;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 6;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 5;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 40;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '80', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_X = 50;
int START_Y = 50;
boolean isDiagonal = true;
boolean isUpRight = false;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = 50;', 'startYPosition': 'int START_Y = 50;', 'isDiagonal': 'boolean isDiagonal = true;', 'isUpRight': 'boolean isUpRight = false;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 10;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                brick.setColor(Color.YELLOW);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '10', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 6;
int BRICK_WIDTH_FIRST_ROW = 20;
int BRICK_HEIGHT_FIRST_ROW = 30;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = 50;
int START_Y_FIRST_ROW = 150;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.YELLOW);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 7;
int BRICK_WIDTH_SECOND_ROW = 40;
int BRICK_HEIGHT_SECOND_ROW = 20;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = -1;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 200;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.YELLOW);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 6;', 'brickWidthFirstRow': '20', 'brickHeightFirstRow': '30', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = 50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 150;', 'brickColor': 'Color.YELLOW', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 7;', 'brickWidthSecondRow': '40', 'brickHeightSecondRow': '20', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = -1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 200;'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(800,400+60)
        // Create a rectangle with the specified position 
        int x = -200; int y = -50;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 200, 100);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(800,400+60)', 'initialPointLocation': '{OffCanvasPositions}', 'offCanvasPosition': 'int x = -200; int y = -50;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 200, 100);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 600);

        // Determine the structure and initialize parameters
        int START_X = -50;
int START_Y = 50;
int NUM_COLUMNS = 7;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
boolean isUpsideDown = false;
boolean isColumn = false;
String input = ""7, 7, 7, 7, 7, 7, 7"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '600', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'structure': 'diagonal', 'numColumns': '7', 'numBricksPerColumn': 'constant', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '10', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Determine the shape and initialize parameters
        int START_X = 50;
int START_Y = 50;
int NUM_ROWS = 10;
int NUM_BRICKS_BASE = 16;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 10;
boolean isUpsideDown = true;
boolean isRightTriangle = false;
String input = ""16, 15, 14, 13, 12, 11, 10, 9, 8, 7"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'shape': 'trapezoid', 'numBricksBase': '16', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '10', 'isUpsideDown': 'true', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 10;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.YELLOW);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '10', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 600);

        // Initialize structure parameters
        int START_X = 50;
int START_Y = 50;
int NUM_ROWS = 6;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = -20;
int HOLE_PROBABILITY = 3;
boolean isUpsideDown = true;
String input = ""6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.BLUE);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '600', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'numBricksBase': '6', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '10', 'rowSeparation': '10', 'horizontalOffset': '-20', 'holeProbability': '3', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the shape and initialize parameters
        int START_X = 100;
int START_Y = 100;
int NUM_ROWS = 15;
int NUM_BRICKS_BASE = 15;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
boolean isUpsideDown = false;
boolean isRightTriangle = true;
String input = ""15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'shape': 'rightTriangle', 'numBricksBase': '15', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '0', 'isUpsideDown': 'false', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 20;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 4;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = 2;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 4;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 2;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.GRAY);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 3;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 5;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 100;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.BLUE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 3;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 10;', 'rowSeparation': 'int ROW_SEP = 5;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 11;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '11', 'brickWidth': '80', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 5;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = 1;
int START_X = -50;
int START_Y = 50;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numRows': 'int NUM_ROWS = 5;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = -50;
int START_Y = 100;
int NUM_COLUMNS = 4;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 5;
boolean isUpsideDown = false;
boolean isColumn = false;
String input = ""4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'structure': 'diagonal', 'numColumns': '4', 'numBricksPerColumn': 'varying', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': '5', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 10;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '10', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400+60);
        // Create a rectangle with the specified position 
        int x = 200; int y = 50;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 75, 150);
        // Add color, optional 
        rect.setFilled(true); rect.setColor(Color.RED);

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(600,400+60);', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 200; int y = 50;', 'rectangleOrientation': '{StandingRectangle}', 'standingRectangleSize': 'GRect rect = new GRect(x, y, 75, 150);', 'rectangleColor': 'rect.setFilled(true); rect.setColor(Color.RED);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Determine the structure and initialize parameters
        int START_X = -50;
int START_Y = -50;
int NUM_COLUMNS = 8;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
boolean isUpsideDown = true;
boolean isColumn = true;
String input = ""8, 8, 8, 8, 8, 8, 8, 8"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GREEN);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'structure': 'column', 'numColumns': '8', 'numBricksPerColumn': 'constant', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': '0', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = 50;
int START_Y = 50;
int NUM_COLUMNS = 3;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
boolean isUpsideDown = true;
boolean isColumn = true;
String input = ""3, 3, 3"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'structure': 'column', 'numColumns': '3', 'numBricksPerColumn': 'constant', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': '5', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(800,400)
        // Create a rectangle with the specified position 
        int x = 75; int y = 75;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 100, 50);
        // Add color, optional 
        rect.setFilled(true); rect.setColor(Color.YELLOW);

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{OffCanvas}', 'OffCanvas': 'setSize(800,400)', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 75; int y = 75;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 100, 50);', 'rectangleColor': 'rect.setFilled(true); rect.setColor(Color.YELLOW);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 100;;
int START_Y = int START_Y = 50;;
int NUM_ROWS = 5;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'numBricksBase': '5', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '0', 'horizontalOffset': '20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 7;
int BRICK_WIDTH_FIRST_ROW = 20;
int BRICK_HEIGHT_FIRST_ROW = 30;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = 1;
int START_X_FIRST_ROW = 100;
int START_Y_FIRST_ROW = -100;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 4;
int BRICK_WIDTH_SECOND_ROW = 30;
int BRICK_HEIGHT_SECOND_ROW = 40;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = -1;
int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 7;', 'brickWidthFirstRow': '20', 'brickHeightFirstRow': '30', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = 1;', 'startXFirstRow': 'int START_X_FIRST_ROW = 100;', 'startYFirstRow': 'int START_Y_FIRST_ROW = -100;', 'brickColor': 'Color.BLACK', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 4;', 'brickWidthSecondRow': '30', 'brickHeightSecondRow': '40', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = -1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.MAGENTA);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 10;
int NUM_ROWS = 20;
int BRICK_WIDTH = 60;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '60', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the shape and initialize parameters
        int START_X = 50;
int START_Y = 100;
int NUM_ROWS = 13;
int NUM_BRICKS_BASE = 13;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 10;
boolean isUpsideDown = true;
boolean isRightTriangle = true;
String input = ""1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'shape': 'rightTriangle', 'numBricksBase': '13', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': '0', 'rowSeparation': '10', 'isUpsideDown': 'true', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 100;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize structure parameters
        int START_X = 50;
int START_Y = 50;
int NUM_ROWS = 7;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 5;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 2;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6, 7"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.GRAY);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'numBricksBase': '7', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': '5', 'rowSeparation': '10', 'horizontalOffset': '20', 'holeProbability': '2', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 600);

        // Initialize brick parameters
        int NUM_BRICKS = 4;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROGUE_BRICK_INDEX = -1;
int START_X = 50;
int START_Y = 100;
boolean isDiagonal = false;
boolean isUpRight = false;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '600', 'numBricks': 'int NUM_BRICKS = 4;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 5;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = 50;', 'startYPosition': 'int START_Y = 100;', 'isDiagonal': 'boolean isDiagonal = false;', 'isUpRight': 'boolean isUpRight = false;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.ORANGE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 10;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 40;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '10', 'brickWidth': '80', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 4;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 8;;
int OFFSET = int OFFSET = -20;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = 2;
int ROGUE_DIAGONAL_INDEX = 1;
int START_X = 100;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLUE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 4;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 8;', 'offset': 'int OFFSET = -20;', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 2;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 6;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 6;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
int ROW_SEP = 10;
int ROGUE_ROW_INDEX = 1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = -50;
int START_Y = 100;
boolean isRogueRow = true;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.ORANGE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numRows': 'int NUM_ROWS = 6;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 6;', 'offset': 'int OFFSET = 20;', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 10;', 'rowSeparation': 'int ROW_SEP = 10;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Determine the structure and initialize parameters
        int START_X = 100;
int START_Y = -50;
int NUM_COLUMNS = 7;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
boolean isUpsideDown = false;
boolean isColumn = true;
String input = ""7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLUE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'structure': 'column', 'numColumns': '7', 'numBricksPerColumn': 'varying', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '0', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters
        int NUM_BRICKS = 4;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_X = 50;
int START_Y = 100;
boolean isDiagonal = true;
boolean isUpRight = true;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 4;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = 50;', 'startYPosition': 'int START_Y = 100;', 'isDiagonal': 'boolean isDiagonal = true;', 'isUpRight': 'boolean isUpRight = true;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Determine the shape and initialize parameters
        int START_X = 50;
int START_Y = 50;
int NUM_ROWS = 16;
int NUM_BRICKS_BASE = 16;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 5;
int ROW_SEP = 10;
boolean isUpsideDown = true;
boolean isRightTriangle = true;
String input = ""1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'shape': 'rightTriangle', 'numBricksBase': '16', 'brickWidth': '30', 'brickHeight': '30', 'brickSeparation': '5', 'rowSeparation': '10', 'isUpsideDown': 'true', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 11;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '11', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize structure parameters
        int START_X = -50;
int START_Y = 100;
int NUM_ROWS = 7;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 5;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 2;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6, 7"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.ORANGE);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'numBricksBase': '7', 'brickWidth': '20', 'brickHeight': '30', 'brickSeparation': '5', 'rowSeparation': '0', 'horizontalOffset': '20', 'holeProbability': '2', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 200);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 6;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
int ROGUE_BRICK_INDEX = 2;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '200', 'numBricks': 'int NUM_BRICKS = 6;', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 10;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 2;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = 100;
int START_Y = 50;
int NUM_COLUMNS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
boolean isUpsideDown = false;
boolean isColumn = false;
String input = ""3, 3, 3"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'structure': 'diagonal', 'numColumns': '3', 'numBricksPerColumn': 'constant', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '10', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 300);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GREEN);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '300', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize brick parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_X = -50;
int START_Y = getHeight() + 60;
boolean isDiagonal = false;
boolean isUpRight = true;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.BLUE);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = -50;', 'startYPosition': 'int START_Y = getHeight() + 60;', 'isDiagonal': 'boolean isDiagonal = false;', 'isUpRight': 'boolean isUpRight = true;', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = 100;
int START_Y = -50;
int NUM_COLUMNS = 4;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
boolean isUpsideDown = false;
boolean isColumn = true;
String input = ""4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'structure': 'column', 'numColumns': '4', 'numBricksPerColumn': 'varying', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '0', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 10;
int NUM_ROWS = 20;
int BRICK_WIDTH = 60;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '60', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 40;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 10;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.ORANGE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '10', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400);
        // Create a rectangle with the specified position 
        int x = 50; int y = 50;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 200, 100);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{OffCanvas}', 'OffCanvas': 'setSize(600,400);', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 50; int y = 50;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 200, 100);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_pyramid', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize structure parameters
        int START_X = 50;
int START_Y = 100;
int NUM_ROWS = 8;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 5;
int ROW_SEP = 5;
int HORIZONTAL_OFFSET = -20;
int HOLE_PROBABILITY = 2;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6, 7, 8"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.BLUE);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 100;', 'numBricksBase': '8', 'brickWidth': '20', 'brickHeight': '30', 'brickSeparation': '5', 'rowSeparation': '5', 'horizontalOffset': '-20', 'holeProbability': '2', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 15;
int NUM_ROWS = 20;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 4;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_Y = -40;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLUE);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 4;', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = -40;', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 300);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 5;
int ROGUE_BRICK_INDEX = 1;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '300', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 5;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 1;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize structure parameters
        int START_X = 50;
int START_Y = 100;
int NUM_ROWS = 8;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = -20;
int HOLE_PROBABILITY = 3;
boolean isUpsideDown = true;
String input = ""8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(true);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.MAGENTA);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 100;', 'numBricksBase': '8', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '10', 'rowSeparation': '10', 'horizontalOffset': '-20', 'holeProbability': '3', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = 2;
int START_Y = getHeight() - 20;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.ORANGE);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 2;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_Y = 40;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = 40;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400,400+60)
        // Create a rectangle with the specified position 
        int x = -100; int y = -100;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 50, 100);
        // Add color, optional 
        rect.setFilled(true); rect.setColor(Color.RED);

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(400,400+60)', 'initialPointLocation': '{OffCanvasPositions}', 'offCanvasPosition': 'int x = -100; int y = -100;', 'rectangleOrientation': '{StandingRectangle}', 'standingRectangleSize': 'GRect rect = new GRect(x, y, 50, 100);', 'rectangleColor': 'rect.setFilled(true); rect.setColor(Color.RED);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 40;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '80', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Determine the structure and initialize parameters
        int START_X = int START_X = -50;;
int START_Y = int START_Y = 50;;
int NUM_ROWS = 6;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = -20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'numBricksBase': '6', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '5', 'rowSeparation': '0', 'horizontalOffset': '-20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickRow extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize starting position and other parameters
        int NUM_BRICKS = 6;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_Y = -40;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = i * (BRICK_WIDTH + BRICK_SEP);
            int y = START_Y - BRICK_HEIGHT / 2;
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.MAGENTA);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickRow().start(args);
    }
}","{'strategies': 'single_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickRow extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeSingleRow}\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickRow().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 6;', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startYPosition': 'int START_Y = -40;', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the shape and initialize parameters
        int START_X = -50;
int START_Y = 100;
int NUM_ROWS = 10;
int NUM_BRICKS_BASE = 16;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 0;
boolean isUpsideDown = false;
boolean isRightTriangle = false;
String input = ""10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.YELLOW);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'shape': 'trapezoid', 'numBricksBase': '16', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '10', 'rowSeparation': '0', 'isUpsideDown': 'false', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 600);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 7;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 8;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 10;
int ROGUE_ROW_INDEX = 2;
int ROGUE_DIAGONAL_INDEX = 2;
int START_X = 100;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.MAGENTA);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '600', 'numRows': 'int NUM_ROWS = 7;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 8;', 'offset': 'int OFFSET = 20;', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 10;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 2;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 2;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 8;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 30;
int BRICK_SEP_FIRST_ROW = 5;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = -50;
int START_Y_FIRST_ROW = 100;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLUE);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 7;
int BRICK_WIDTH_SECOND_ROW = 40;
int BRICK_HEIGHT_SECOND_ROW = 20;
int BRICK_SEP_SECOND_ROW = 10;
int ROGUE_BRICK_INDEX_SECOND_ROW = 2;
int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLUE);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 8;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '30', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 5;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = -50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 100;', 'brickColor': 'Color.BLUE', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 7;', 'brickWidthSecondRow': '40', 'brickHeightSecondRow': '20', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 10;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = 2;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 10;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '10', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 7;
int NUM_ROWS = 10;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '80', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 11;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.YELLOW);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '11', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 12;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.ORANGE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '12', 'brickWidth': '40', 'brickHeight': '20', 'centeringAssistLines': 'add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 8;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 20;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = 50;
int START_Y_FIRST_ROW = -50;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.MAGENTA);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 7;
int BRICK_WIDTH_SECOND_ROW = 40;
int BRICK_HEIGHT_SECOND_ROW = 30;
int BRICK_SEP_SECOND_ROW = 5;
int ROGUE_BRICK_INDEX_SECOND_ROW = -1;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 200;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.MAGENTA);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 8;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '20', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = 50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = -50;', 'brickColor': 'Color.MAGENTA', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 7;', 'brickWidthSecondRow': '40', 'brickHeightSecondRow': '30', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 5;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = -1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 200;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 8;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 4;;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = 2;
int ROGUE_DIAGONAL_INDEX = 2;
int START_X = 100;
int START_Y = -50;
boolean isRogueRow = true;
boolean isRogueDiagonal = true;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numRows': 'int NUM_ROWS = 8;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 4;', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 2;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 2;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 3;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 20;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = -100;
int START_Y_FIRST_ROW = -50;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 8;
int BRICK_WIDTH_SECOND_ROW = 20;
int BRICK_HEIGHT_SECOND_ROW = 20;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = -1;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 3;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '20', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = -100;', 'startYFirstRow': 'int START_Y_FIRST_ROW = -50;', 'brickColor': 'Color.BLACK', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 8;', 'brickWidthSecondRow': '20', 'brickHeightSecondRow': '20', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = -1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the shape and initialize parameters
        int START_X = 100;
int START_Y = 50;
int NUM_ROWS = 14;
int NUM_BRICKS_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
boolean isUpsideDown = true;
boolean isRightTriangle = true;
String input = ""1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'shape': 'rightTriangle', 'numBricksBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '0', 'isUpsideDown': 'true', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 5;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 6;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 10;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 100;
int START_Y = 100;
boolean isRogueRow = true;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.MAGENTA);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 5;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 6;', 'offset': 'int OFFSET = 20;', 'brickWidth': '20', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 10;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 100;;
int START_Y = int START_Y = 100;;
int NUM_ROWS = 7;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6, 7"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.YELLOW);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'numBricksBase': '7', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '0', 'rowSeparation': '0', 'horizontalOffset': '20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 3;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 5;
int ROGUE_ROW_INDEX = 1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 50;
int START_Y = 50;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 3;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 5;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                brick.setColor(Color.YELLOW);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = 2;
int START_X = 50;
int START_Y = 50;
boolean isDiagonal = true;
boolean isUpRight = true;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.BLUE);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '20', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 2;', 'startXPosition': 'int START_X = 50;', 'startYPosition': 'int START_Y = 50;', 'isDiagonal': 'boolean isDiagonal = true;', 'isUpRight': 'boolean isUpRight = true;', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickWallStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int NUM_COLUMNS = 10;
int NUM_ROWS = 20;
int BRICK_WIDTH = 60;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;

        // Draw rows of bricks covering the entire screen without offset
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLUMNS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT;
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.BLACK);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickWallStructure().start(args);
    }
}","{'strategies': 'brick_wall', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickWallStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeBrickWall}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickWallStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'brickWidth': '60', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.GRAY);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 600);

        // Determine the shape and initialize parameters
        int START_X = -50;
int START_Y = 50;
int NUM_ROWS = 16;
int NUM_BRICKS_BASE = 16;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
int ROW_SEP = 5;
boolean isUpsideDown = false;
boolean isRightTriangle = true;
String input = ""16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '600', 'shape': 'rightTriangle', 'numBricksBase': '16', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '10', 'rowSeparation': '5', 'isUpsideDown': 'false', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 5;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 8;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = 2;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 50;
int START_Y = -50;
boolean isRogueRow = false;
boolean isRogueDiagonal = true;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.ORANGE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numRows': 'int NUM_ROWS = 5;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 8;', 'offset': 'int OFFSET = 20;', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 2;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = -50;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Determine the structure and initialize parameters
        int START_X = 50;
int START_Y = -50;
int NUM_COLUMNS = 6;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
boolean isUpsideDown = false;
boolean isColumn = false;
String input = ""6, 6, 6, 6, 6, 6"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = -50;', 'structure': 'diagonal', 'numColumns': '6', 'numBricksPerColumn': 'constant', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '0', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 100;;
int START_Y = int START_Y = -50;;
int NUM_ROWS = 3;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 5;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = -20;
boolean isUpsideDown = false;
String input = ""1, 2, 3"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'numBricksBase': '3', 'brickWidth': '20', 'brickHeight': '40', 'brickSeparation': '5', 'rowSeparation': '0', 'horizontalOffset': '-20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400+60);
        // Create a rectangle with the specified position 
        int x = 100; int y = 100;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 75, 150);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(600,400+60);', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 100; int y = 100;', 'rectangleOrientation': '{StandingRectangle}', 'standingRectangleSize': 'GRect rect = new GRect(x, y, 75, 150);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400,400)
        // Create a rectangle with the specified position 
        int x = 200; int y = 50;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 50, 100);
        // Add color, optional 
        rect.setFilled(true); rect.setColor(Color.MAGENTA);

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{OffCanvas}', 'OffCanvas': 'setSize(400,400)', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 200; int y = 50;', 'rectangleOrientation': '{StandingRectangle}', 'standingRectangleSize': 'GRect rect = new GRect(x, y, 50, 100);', 'rectangleColor': 'rect.setFilled(true); rect.setColor(Color.MAGENTA);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.ORANGE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 10;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 40;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.YELLOW);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '10', 'brickWidth': '80', 'brickHeight': '40', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 600);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 5;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 5;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 10;
int ROGUE_ROW_INDEX = 2;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = -50;
int START_Y = 50;
boolean isRogueRow = true;
boolean isRogueDiagonal = false;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '600', 'numRows': 'int NUM_ROWS = 5;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 5;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 10;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 2;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = 2;
int START_X = 50;
int START_Y = 50;
boolean isDiagonal = true;
boolean isUpRight = false;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 2;', 'startXPosition': 'int START_X = 50;', 'startYPosition': 'int START_Y = 50;', 'isDiagonal': 'boolean isDiagonal = true;', 'isUpRight': 'boolean isUpRight = false;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 14;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '14', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = -50;;
int START_Y = int START_Y = 50;;
int NUM_ROWS = 5;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GREEN);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'numBricksBase': '5', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '0', 'horizontalOffset': '20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = 1;
int START_X = 50;
int START_Y = getHeight() - 20;
boolean isDiagonal = true;
boolean isUpRight = false;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.GRAY);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '20', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = 1;', 'startXPosition': 'int START_X = 50;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'isDiagonal': 'boolean isDiagonal = true;', 'isUpRight': 'boolean isUpRight = false;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Determine the structure and initialize parameters
        int START_X = -50;
int START_Y = 50;
int NUM_COLUMNS = 7;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
boolean isUpsideDown = false;
boolean isColumn = true;
String input = ""7, 7, 7, 7, 7, 7, 7"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.YELLOW);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'structure': 'column', 'numColumns': '7', 'numBricksPerColumn': 'constant', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '5', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Determine the shape and initialize parameters
        int START_X = 50;
int START_Y = 100;
int NUM_ROWS = 16;
int NUM_BRICKS_BASE = 16;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROW_SEP = 5;
boolean isUpsideDown = false;
boolean isRightTriangle = true;
String input = ""16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.MAGENTA);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'shape': 'rightTriangle', 'numBricksBase': '16', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': '5', 'rowSeparation': '5', 'isUpsideDown': 'false', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 100;', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400,400+60)
        // Create a rectangle with the specified position 
        int x = 200; int y = 50;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 100, 50);
        // Add color, optional 
        rect.setFilled(true); rect.setColor(Color.MAGENTA);

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(400,400+60)', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 200; int y = 50;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 100, 50);', 'rectangleColor': 'rect.setFilled(true); rect.setColor(Color.MAGENTA);'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400+60);
        // Create a rectangle with the specified position 
        int x = 75; int y = 75;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 100, 200);
        // Add color, optional 
        rect.setFilled(true); rect.setColor(Color.BLUE);

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(600,400+60);', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 75; int y = 75;', 'rectangleOrientation': '{StandingRectangle}', 'standingRectangleSize': 'GRect rect = new GRect(x, y, 100, 200);', 'rectangleColor': 'rect.setFilled(true); rect.setColor(Color.BLUE);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 11;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '11', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Determine the structure and initialize parameters
        int START_X = int START_X = -50;;
int START_Y = int START_Y = -50;;
int NUM_ROWS = 6;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'numBricksBase': '6', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '0', 'horizontalOffset': '20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_X = 50;
int START_Y = getHeight() + 60;
boolean isDiagonal = true;
boolean isUpRight = false;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = 50;', 'startYPosition': 'int START_Y = getHeight() + 60;', 'isDiagonal': 'boolean isDiagonal = true;', 'isUpRight': 'boolean isUpRight = false;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters
        int NUM_BRICKS = 4;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_X = 100;
int START_Y = getHeight() + 60;
boolean isDiagonal = true;
boolean isUpRight = true;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.BLUE);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 4;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = 100;', 'startYPosition': 'int START_Y = getHeight() + 60;', 'isDiagonal': 'boolean isDiagonal = true;', 'isUpRight': 'boolean isUpRight = true;', 'brickColor': 'Color.BLUE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = -50;
int START_Y = -50;
int NUM_COLUMNS = 7;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
boolean isUpsideDown = false;
boolean isColumn = true;
String input = ""7, 7, 7, 7, 7, 7, 7"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.YELLOW);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'structure': 'column', 'numColumns': '7', 'numBricksPerColumn': 'constant', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '0', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_X = 50;
int START_Y = getHeight() - 20;
boolean isDiagonal = false;
boolean isUpRight = true;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.GREEN);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = 50;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'isDiagonal': 'boolean isDiagonal = false;', 'isUpRight': 'boolean isUpRight = true;', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 100;;
int START_Y = int START_Y = 100;;
int NUM_ROWS = 7;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 10;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = -20;
boolean isUpsideDown = true;
String input = ""7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'numBricksBase': '7', 'brickWidth': '20', 'brickHeight': '40', 'brickSeparation': '10', 'rowSeparation': '0', 'horizontalOffset': '-20', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 50;;
int START_Y = int START_Y = 50;;
int NUM_ROWS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = false;
String input = ""1, 2, 3"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.ORANGE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'numBricksBase': '3', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '0', 'horizontalOffset': '20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 50;;
int START_Y = int START_Y = -50;;
int NUM_ROWS = 6;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '260', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = -50;', 'numBricksBase': '6', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '5', 'rowSeparation': '10', 'horizontalOffset': '20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 80;
int BRICK_HEIGHT = 20;

        // Optionally add centering assist lines
        // No assist lines by default

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.GRAY);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '80', 'brickHeight': '20', 'centeringAssistLines': '// No assist lines by default', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.MAGENTA);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '20', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.MAGENTA'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 7;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 20;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = 50;
int START_Y_FIRST_ROW = 50;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.YELLOW);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 7;
int BRICK_WIDTH_SECOND_ROW = 40;
int BRICK_HEIGHT_SECOND_ROW = 20;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = -1;
int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.YELLOW);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 7;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '20', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = 50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 50;', 'brickColor': 'Color.YELLOW', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 7;', 'brickWidthSecondRow': '40', 'brickHeightSecondRow': '20', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = -1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 50;;
int START_Y = int START_Y = -50;;
int NUM_ROWS = 3;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = false;
String input = ""1, 2, 3"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = -50;', 'numBricksBase': '3', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '0', 'rowSeparation': '0', 'horizontalOffset': '20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400+60);
        // Create a rectangle with the specified position 
        int x = 150; int y = 150;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 100, 50);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{RightCanvas}', 'RightCanvas': 'setSize(600,400+60);', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 150; int y = 150;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 100, 50);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 3;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 3;;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = -1;
int START_X = 50;
int START_Y = 50;
boolean isRogueRow = true;
boolean isRogueDiagonal = false;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 3;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 3;', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 5;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = -1;', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawOffsetPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 13;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;

        // Optionally add centering assist lines
        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.GREEN);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawOffsetPyramidStructure().start(args);
    }
}","{'strategies': 'offset_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawOffsetPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawOffsetPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '13', 'brickWidth': '40', 'brickHeight': '40', 'centeringAssistLines': 'add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize structure parameters
        int START_X = 100;
int START_Y = 100;
int NUM_ROWS = 8;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 5;
int ROW_SEP = 5;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 2;
boolean isUpsideDown = true;
String input = ""8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(true);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.BLACK);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 100;', 'numBricksBase': '8', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': '5', 'rowSeparation': '5', 'horizontalOffset': '20', 'holeProbability': '2', 'isUpsideDown': 'true', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(true);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRectangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 600);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 8;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 10;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = 2;
int ROGUE_DIAGONAL_INDEX = 2;
int START_X = 50;
int START_Y = 50;
boolean isRogueRow = true;
boolean isRogueDiagonal = false;

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(true);
                    brick.setColor(Color.RED);
                } else {
                    brick.setFilled(true);
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangleStructure().start(args);
    }
}","{'strategies': 'rectangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRectangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRectangle}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '600', 'numRows': 'int NUM_ROWS = 8;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 10;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = 2;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 2;', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawColumnStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = 50;
int START_Y = 50;
int NUM_COLUMNS = 3;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
boolean isUpsideDown = false;
boolean isColumn = true;
String input = ""3, 3, 3"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw columns or diagonals of bricks
        for (int col = 0; col < NUM_COLUMNS; col++) {
            int numBricks = NUM_BRICKS[col];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue column/diagonal condition
                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.BLACK);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawColumnStructure().start(args);
    }
}","{'strategies': 'column_structure', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawColumnStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeColumn}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue column/diagonal condition\n                if ((col == ROGUE_COLUMN_INDEX && isRogueColumn) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorColumn});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawColumnStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = 50;', 'structure': 'column', 'numColumns': '3', 'numBricksPerColumn': 'constant', 'brickWidth': '30', 'brickHeight': '20', 'brickSeparation': '10', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 8;
int BRICK_WIDTH_FIRST_ROW = 40;
int BRICK_HEIGHT_FIRST_ROW = 30;
int BRICK_SEP_FIRST_ROW = 0;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = 100;
int START_Y_FIRST_ROW = 50;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 8;
int BRICK_WIDTH_SECOND_ROW = 30;
int BRICK_HEIGHT_SECOND_ROW = 40;
int BRICK_SEP_SECOND_ROW = 0;
int ROGUE_BRICK_INDEX_SECOND_ROW = -1;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 8;', 'brickWidthFirstRow': '40', 'brickHeightFirstRow': '30', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 0;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = 100;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 50;', 'brickColor': 'Color.BLACK', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 8;', 'brickWidthSecondRow': '30', 'brickHeightSecondRow': '40', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 0;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = -1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 5;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 7;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = 1;
int START_X = -50;
int START_Y = 100;
boolean isRogueRow = false;
boolean isRogueDiagonal = false;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.ORANGE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 5;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 7;', 'offset': 'int OFFSET = 20;', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 0;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 100;', 'isRogueRow': 'boolean isRogueRow = false;', 'isRogueDiagonal': 'boolean isRogueDiagonal = false;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Determine the structure and initialize parameters
        int START_X = int START_X = -50;;
int START_Y = int START_Y = 50;;
int NUM_ROWS = 4;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.ORANGE);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'numBricksBase': '4', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '0', 'rowSeparation': '0', 'horizontalOffset': '20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawPyramidStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Initialize structure parameters
        int BRICKS_IN_BASE = 11;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;

        // Draw a pyramid
        for (int i = 0; i < BRICKS_IN_BASE; i++) {
            // Calculate row variables
            int nBricks = BRICKS_IN_BASE - i;
            int rowWidth = nBricks * BRICK_WIDTH;
            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;
            double rowX = (getWidth() - rowWidth) / 2.0;

            // Draw a single row
            for (int j = 0; j < nBricks; j++) {
                // Add a single brick
                double x = rowX + j * BRICK_WIDTH;
                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                brick.setColor(Color.ORANGE);
                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawPyramidStructure().start(args);
    }
}","{'strategies': 'perfect_extra', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawPyramidStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizePyramid}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawPyramidStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'bricksInBase': '11', 'brickWidth': '40', 'brickHeight': '40', 'brickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.ORANGE'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 600);

        // Initialize structure parameters
        int START_X = -50;
int START_Y = -50;
int NUM_ROWS = 7;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 2;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6, 7"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.BLACK);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '600', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = -50;', 'numBricksBase': '7', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '10', 'rowSeparation': '10', 'horizontalOffset': '20', 'holeProbability': '2', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 400);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 100;;
int START_Y = int START_Y = 50;;
int NUM_ROWS = 7;
int BRICK_WIDTH = 30;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6, 7"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.YELLOW);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '400', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'numBricksBase': '7', 'brickWidth': '30', 'brickHeight': '40', 'brickSeparation': '0', 'rowSeparation': '0', 'horizontalOffset': '20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600,400);
        // Create a rectangle with the specified position 
        int x = 100; int y = 100;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 200, 100);
        // Add color, optional 
        rect.setFilled(true); rect.setColor(Color.YELLOW);

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{OffCanvas}', 'OffCanvas': 'setSize(600,400);', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 100; int y = 100;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 200, 100);', 'rectangleColor': 'rect.setFilled(true); rect.setColor(Color.YELLOW);'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawParallelogramStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters for rows
        int NUM_ROWS = int NUM_ROWS = 6;;
int NUM_BRICKS_PER_ROW = int NUM_BRICKS_PER_ROW = 6;;
int OFFSET = int OFFSET = 20;;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 0;
int ROGUE_ROW_INDEX = -1;
int ROGUE_DIAGONAL_INDEX = 1;
int START_X = -50;
int START_Y = 50;
boolean isRogueRow = true;
boolean isRogueDiagonal = true;

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * OFFSET;
            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.YELLOW);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawParallelogramStructure().start(args);
    }
}","{'strategies': 'parallelogram', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawParallelogramStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeParallelogram}\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawParallelogramStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numRows': 'int NUM_ROWS = 6;', 'numBricksPerRow': 'int NUM_BRICKS_PER_ROW = 6;', 'offset': 'int OFFSET = 20;', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 10;', 'rowSeparation': 'int ROW_SEP = 0;', 'rogueRowIndex': 'int ROGUE_ROW_INDEX = -1;', 'rogueDiagonalIndex': 'int ROGUE_DIAGONAL_INDEX = 1;', 'startX': 'int START_X = -50;', 'startY': 'int START_Y = 50;', 'isRogueRow': 'boolean isRogueRow = true;', 'isRogueDiagonal': 'boolean isRogueDiagonal = true;', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.YELLOW'}"
"import acm.graphics.*;
import acm.program.*;

public class DrawRectangle extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(800,400)
        // Create a rectangle with the specified position 
        int x = 300; int y = 100;
        // Specify size of the rectangle 
        GRect rect = new GRect(x, y, 100, 50);
        // Add color, optional 
        //no color

        // Add the rectangle to the canvas
        add(rect);
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRectangle().start(args);
    }
}","{'strategies': 'hello_world', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawRectangle extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasHelloWorld}\n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        add(rect);\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRectangle().start(args);\n    }}\n}}', 'canvasSetting': '{OffCanvas}', 'OffCanvas': 'setSize(800,400)', 'initialPointLocation': '{OnCanvasPositions}', 'onCanvasPosition': 'int x = 300; int y = 100;', 'rectangleOrientation': '{LyingDownRectangle}', 'lyingDownRectangleSize': 'GRect rect = new GRect(x, y, 100, 50);', 'rectangleColor': '//no color'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize structure parameters
        int START_X = 50;
int START_Y = -50;
int NUM_ROWS = 6;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 5;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = 20;
int HOLE_PROBABILITY = 3;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(true);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.BLACK);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = -50;', 'numBricksBase': '6', 'brickWidth': '40', 'brickHeight': '40', 'brickSeparation': '5', 'rowSeparation': '0', 'horizontalOffset': '20', 'holeProbability': '3', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;
import java.util.Random;

public class DrawRoughlySymmetricStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize structure parameters
        int START_X = 100;
int START_Y = 50;
int NUM_ROWS = 7;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 40;
int BRICK_SEP = 0;
int ROW_SEP = 10;
int HORIZONTAL_OFFSET = -20;
int HOLE_PROBABILITY = 2;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5, 6, 7"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        Random rand = new Random();

        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < NUM_BRICKS[row]; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);

                // Randomly decide if there is a hole (missing brick)
                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);

                if (!hasHole) {
                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                    // Determine if the brick is filled
                    brick.setFilled(false);

                    // Add a rogue row/diagonal condition
                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                        brick.setFilled(false);
                        brick.setColor(Color.RED);
                    } else {
                        brick.setColor(Color.BLACK);
                    }

                    add(brick);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRoughlySymmetricStructure().start(args);
    }
}","{'strategies': 'pyramid_like', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\nimport java.util.Random;\n\npublic class DrawRoughlySymmetricStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRoughlySymmetric}\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n\n                    // Add a rogue row/diagonal condition\n                    if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                        {SetRogueBrickFilled}\n                        brick.setColor(Color.RED);\n                    }} else {{\n                        brick.setColor({BrickColorRoughlySymmetric});\n                    }}\n\n                    add(brick);\n                }}\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRoughlySymmetricStructure().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = 50;', 'numBricksBase': '7', 'brickWidth': '20', 'brickHeight': '40', 'brickSeparation': '0', 'rowSeparation': '10', 'horizontalOffset': '-20', 'holeProbability': '2', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 400);

        // Initialize brick parameters
        int NUM_BRICKS = 3;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 10;
int ROGUE_BRICK_INDEX = -1;
int START_X = 100;
int START_Y = getHeight() + 60;
boolean isDiagonal = true;
boolean isUpRight = false;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.GREEN);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '400', 'numBricks': 'int NUM_BRICKS = 3;', 'brickWidth': '20', 'brickHeight': '30', 'brickSeparation': 'int BRICK_SEP = 10;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = 100;', 'startYPosition': 'int START_Y = getHeight() + 60;', 'isDiagonal': 'boolean isDiagonal = true;', 'isUpRight': 'boolean isUpRight = false;', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 600);

        // Determine the shape and initialize parameters
        int START_X = 100;
int START_Y = -50;
int NUM_ROWS = 15;
int NUM_BRICKS_BASE = 15;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 10;
int ROW_SEP = 0;
boolean isUpsideDown = false;
boolean isRightTriangle = true;
String input = ""15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }

        // Draw rows of bricks
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            for (int i = 0; i < numBricks; i++) {
                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(true);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GRAY);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleStructure().start(args);
    }
}","{'strategies': 'right_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangle}\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangle});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '600', 'shape': 'rightTriangle', 'numBricksBase': '15', 'brickWidth': '40', 'brickHeight': '20', 'brickSeparation': '10', 'rowSeparation': '0', 'isUpsideDown': 'false', 'startX': 'int START_X = 100;', 'startY': 'int START_Y = -50;', 'brickFilled': 'brick.setFilled(true);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GRAY'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 600);

        // Determine the structure and initialize parameters
        int START_X = int START_X = 50;;
int START_Y = int START_Y = -50;;
int NUM_ROWS = 5;
int BRICK_WIDTH = 40;
int BRICK_HEIGHT = 30;
int BRICK_SEP = 10;
int ROW_SEP = 0;
int HORIZONTAL_OFFSET = -20;
boolean isUpsideDown = false;
String input = ""1, 2, 3, 4, 5"";
        
        // Convert String to int array 
        String[] stringArray = input.split("","");
        int[] NUM_BRICKS = new int[stringArray.length];
        for (int i = 0; i < stringArray.length; i++) {
            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());
        }
        // Draw rows of bricks with horizontal offset
        for (int row = 0; row < NUM_ROWS; row++) {
            int numBricks = NUM_BRICKS[row];
            int initialX = START_X + row * HORIZONTAL_OFFSET;
            for (int i = 0; i < numBricks; i++) {
                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);
                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);
                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

                // Determine if the brick is filled
                brick.setFilled(false);

                // Add a rogue row/diagonal condition
                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {
                    brick.setFilled(false);
                    brick.setColor(Color.RED);
                } else {
                    brick.setColor(Color.GREEN);
                }

                add(brick);
            }
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawRightTriangleHorizontalOffsetStructure().start(args);
    }
}","{'strategies': 'scalene_triangle', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawRightTriangleHorizontalOffsetStructure extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeRightTriangleHorizontalOffset}\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split("","");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorRightTriangleHorizontalOffset});\n                }}\n\n                add(brick);\n            }}\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawRightTriangleHorizontalOffsetStructure().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '600', 'startX': 'int START_X = 50;', 'startY': 'int START_Y = -50;', 'numBricksBase': '5', 'brickWidth': '40', 'brickHeight': '30', 'brickSeparation': '10', 'rowSeparation': '0', 'horizontalOffset': '-20', 'isUpsideDown': 'false', 'brickFilled': 'brick.setFilled(false);', 'rogueBrickFilled': 'brick.setFilled(false);', 'brickColor': 'Color.GREEN'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawBrickPattern extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(400, 260);

        // Initialize brick parameters
        int NUM_BRICKS = 5;
int BRICK_WIDTH = 20;
int BRICK_HEIGHT = 20;
int BRICK_SEP = 0;
int ROGUE_BRICK_INDEX = -1;
int START_X = 100;
int START_Y = getHeight() - 20;
boolean isDiagonal = false;
boolean isUpRight = false;

        // Draw bricks
        for (int i = 0; i < NUM_BRICKS; i++) {
            int x = START_X;
            int y = START_Y;
            if (isDiagonal) {
                if (isUpRight) {
                    x += i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                } else {
                    x -= i * (BRICK_WIDTH + BRICK_SEP);
                    y -= i * (BRICK_HEIGHT + BRICK_SEP);
                }
            } else {
                y += i * (BRICK_HEIGHT + BRICK_SEP);
            }
            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);

            // Add a rogue brick condition
            if (i == ROGUE_BRICK_INDEX) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setFilled(true);
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawBrickPattern().start(args);
    }
}","{'strategies': 'diagonal', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawBrickPattern extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeDiagonal}\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawBrickPattern().start(args);\n    }}\n}}', 'canvasWidth': '400', 'canvasHeight': '260', 'numBricks': 'int NUM_BRICKS = 5;', 'brickWidth': '20', 'brickHeight': '20', 'brickSeparation': 'int BRICK_SEP = 0;', 'rogueBrickIndex': 'int ROGUE_BRICK_INDEX = -1;', 'startXPosition': 'int START_X = 100;', 'startYPosition': 'int START_Y = getHeight() - 20;', 'isDiagonal': 'boolean isDiagonal = false;', 'isUpRight': 'boolean isUpRight = false;', 'brickColor': 'Color.BLACK'}"
"import acm.graphics.*;
import acm.program.*;
import java.awt.Color;

public class DrawTwoRows extends GraphicsProgram {
    public void run() {
        // Set canvas size
        setSize(600, 600);

        // Initialize brick parameters for first row
        int NUM_BRICKS_FIRST_ROW = 3;
int BRICK_WIDTH_FIRST_ROW = 30;
int BRICK_HEIGHT_FIRST_ROW = 40;
int BRICK_SEP_FIRST_ROW = 5;
int ROGUE_BRICK_INDEX_FIRST_ROW = -1;
int START_X_FIRST_ROW = -50;
int START_Y_FIRST_ROW = 50;

        // Draw first row of bricks
        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {
            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);
            int y = START_Y_FIRST_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);

            // Add a rogue brick condition for the first row
            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }

        // Initialize brick parameters for second row
        int NUM_BRICKS_SECOND_ROW = 7;
int BRICK_WIDTH_SECOND_ROW = 40;
int BRICK_HEIGHT_SECOND_ROW = 40;
int BRICK_SEP_SECOND_ROW = 10;
int ROGUE_BRICK_INDEX_SECOND_ROW = -1;
int START_X_SECOND_ROW = START_X_FIRST_ROW;
int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;

        // Draw second row of bricks
        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {
            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);
            int y = START_Y_SECOND_ROW;
            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);

            // Add a rogue brick condition for the second row
            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {
                brick.setFilled(true);
                brick.setColor(Color.RED);
            } else {
                brick.setColor(Color.BLACK);
            }

            add(brick);
        }
    }

    public static void main(String[] args) {
        // Start the GraphicsProgram
        new DrawTwoRows().start(args);
    }
}","{'strategies': 'two_row', 'codeStructure': 'import acm.graphics.*;\nimport acm.program.*;\nimport java.awt.Color;\n\npublic class DrawTwoRows extends GraphicsProgram {{\n    public void run() {{\n        // Set canvas size\n        {SetCanvasSizeTwoRows}\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n    }}\n\n    public static void main(String[] args) {{\n        // Start the GraphicsProgram\n        new DrawTwoRows().start(args);\n    }}\n}}', 'canvasWidth': '600', 'canvasHeight': '600', 'numBricksFirstRow': 'int NUM_BRICKS_FIRST_ROW = 3;', 'brickWidthFirstRow': '30', 'brickHeightFirstRow': '40', 'brickSeparationFirstRow': 'int BRICK_SEP_FIRST_ROW = 5;', 'rogueBrickIndexFirstRow': 'int ROGUE_BRICK_INDEX_FIRST_ROW = -1;', 'startXFirstRow': 'int START_X_FIRST_ROW = -50;', 'startYFirstRow': 'int START_Y_FIRST_ROW = 50;', 'brickColor': 'Color.BLACK', 'numBricksSecondRow': 'int NUM_BRICKS_SECOND_ROW = 7;', 'brickWidthSecondRow': '40', 'brickHeightSecondRow': '40', 'brickSeparationSecondRow': 'int BRICK_SEP_SECOND_ROW = 10;', 'rogueBrickIndexSecondRow': 'int ROGUE_BRICK_INDEX_SECOND_ROW = -1;', 'startXSecondRow': 'int START_X_SECOND_ROW = START_X_FIRST_ROW;', 'startYSecondRow': 'int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;'}"
