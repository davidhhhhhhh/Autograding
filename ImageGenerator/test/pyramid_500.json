[
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 200; int y = 350;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 200; int y = 350;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 150;\nint START_Y = 350;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 350;",
            "numBricksBase": "6",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "2",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100 + 100;\nint START_Y = 100 + 50;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100 + 100;",
            "startYPosition": "int START_Y = 100 + 50;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100 - 50;\nint START_Y = 100 + 350;\nboolean isDiagonal = false;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100 - 50;",
            "startYPosition": "int START_Y = 100 + 350;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100 - 50;\nint START_Y = 100 + 300;\nboolean isDiagonal = false;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100 - 50;",
            "startYPosition": "int START_Y = 100 + 300;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(true);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 7;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 300 + 100;\nint START_Y = 100 + 50;\nboolean isDiagonal = false;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 300 + 100;",
            "startYPosition": "int START_Y = 100 + 50;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 200;;\nint START_Y = 550;;\nint NUM_ROWS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = true;\nString input = \"4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 550;",
            "numBricksBase": "4",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 50;\nint START_Y = 50;\nint NUM_ROWS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "8",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "2",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 7;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 0;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 3;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 7;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 0;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 3;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 8;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 300;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 4;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 5;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 8;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 300;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 4;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 5;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 300 + 100;\nint START_Y = 100 + 400;\nint NUM_COLUMNS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 15;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"4, 4, 4, 4\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 300 + 100;",
            "startY": "int START_Y = 100 + 400;",
            "structure": "column",
            "numColumns": "4",
            "numBricksPerColumn": "constant",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "15",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 4;;\nint NUM_BRICKS_PER_ROW = 3;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 1;\nint START_X = 50;\nint START_Y = 400;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 4;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 3;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 750;;\nint START_Y = 550;;\nint NUM_ROWS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = true;\nString input = \"3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 550;",
            "numBricksBase": "3",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 150;\nint START_Y = 500;\nint NUM_ROWS = 14;\nint NUM_BRICKS_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = true;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "rightTriangle",
            "numBricksBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 500;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 20;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 6;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 300;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 6;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 300;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 150;\nint START_Y = 450;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = false;\nString input = \"10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "trapezoid",
            "numBricksBase": "16",
            "brickWidth": "20",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 450;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = 20;\n\n        // Optionally add centering assist lines\n        canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "10",
            "OFFSET_Y": "20",
            "OFFSET_X": "20",
            "centeringAssistLines": "canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 300 + 100;\nint START_Y = 100 + 350;\nint NUM_COLUMNS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 15;\nboolean isUpsideDown = true;\nboolean isColumn = true;\nString input = \"5, 5, 5, 5, 5\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 300 + 100;",
            "startY": "int START_Y = 100 + 350;",
            "structure": "column",
            "numColumns": "5",
            "numBricksPerColumn": "constant",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "15",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 750;\nint START_Y = 550;\nint NUM_ROWS = 15;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "rightTriangle",
            "numBricksBase": "15",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 550;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = -20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-20",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 7;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 3;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 7;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 3;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100;\nint START_Y = 100 + 100;\nboolean isDiagonal = false;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100;",
            "startYPosition": "int START_Y = 100 + 100;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 750;\nint START_Y = 550;\nint NUM_ROWS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 3;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 550;",
            "numBricksBase": "8",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "3",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLUE);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 8;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 550;\nint START_Y = 500;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 8;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "20",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 550;",
            "startY": "int START_Y = 500;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 150;\nint START_Y = 500;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = false;\nString input = \"15, 14, 13, 12, 11, 10, 9, 8, 7, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "trapezoid",
            "numBricksBase": "15",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 500;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 500;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = true;\nString input = \"7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 500;",
            "numBricksBase": "7",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 150;;\nint START_Y = 400;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = true;\nString input = \"7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 400;",
            "numBricksBase": "7",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.RED);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.RED"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 3;;\nint OFFSET = -20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 2;\nint START_X = 50;\nint START_Y = 400;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 3;",
            "offset": "int OFFSET = -20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 2;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 4;;\nint OFFSET = -20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 200;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 4;",
            "offset": "int OFFSET = -20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 5;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 175; int y = 275;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 175; int y = 275;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 400;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 6;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 150;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 7;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 6;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 150;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 7;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 8;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 150;\nint START_Y = 100;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 8;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 60;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 100 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - (row + 1) * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "20",
            "offsetX": "int x = - 100 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - (row + 1) * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 300 + 100;\nint START_Y = 100 + 300;\nboolean isDiagonal = false;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 4;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 300 + 100;",
            "startYPosition": "int START_Y = 100 + 300;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 7;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 5;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 300;\nint START_Y_FIRST_ROW = 450;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 6;\nint BRICK_WIDTH_SECOND_ROW = 20;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 10;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 7;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 5;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 300;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 450;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 6;",
            "brickWidthSecondRow": "20",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 10;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 25; int y = 550;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 20);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = 25; int y = 550;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 20);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(true);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 300; int y = 300;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        rect.setFilled(false); rect.setColor(Color.GREEN);\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 300; int y = 300;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "rect.setFilled(false); rect.setColor(Color.GREEN);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100;\nint START_Y = 100 + 100;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100;",
            "startYPosition": "int START_Y = 100 + 100;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x =   100 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 600 - (row + 1) * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "10",
            "offsetX": "int x =   100 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 600 - (row + 1) * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = 50;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = false;\nString input = \"10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "trapezoid",
            "numBricksBase": "16",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 150; int y = 450;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 150; int y = 450;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 30 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - row * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "10",
            "offsetX": "int x = - 30 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - row * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 200;;\nint START_Y = 400;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = true;\nString input = \"6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 400;",
            "numBricksBase": "6",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 20;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 30 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - row * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "10",
            "offsetX": "int x = - 30 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - row * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 8;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 8;",
            "brickWidth": "20",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = -20;\n\n        // Optionally add centering assist lines\n        canvas.add(new GLine(canvas.getWidth() / 2, 0, canvas.getWidth() / 2, canvas.getHeight()));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-20",
            "OFFSET_X": "40",
            "centeringAssistLines": "canvas.add(new GLine(canvas.getWidth() / 2, 0, canvas.getWidth() / 2, canvas.getHeight()));",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100 + 50;\nint START_Y = 100 + 100;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 4;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100 + 50;",
            "startYPosition": "int START_Y = 100 + 100;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 500;;\nint NUM_ROWS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 500;",
            "numBricksBase": "5",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 150;;\nint START_Y = 50;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "6",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 30 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - (row + 1) * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "10",
            "offsetX": "int x = - 30 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - (row + 1) * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 5;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 150;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "brickWidth": "30",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 300 + 100;\nint START_Y = 100 + 50;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 300 + 100;",
            "startYPosition": "int START_Y = 100 + 50;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-30",
            "OFFSET_X": "20",
            "centeringAssistLines": "canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 4;;\nint NUM_BRICKS_PER_ROW = 8;;\nint OFFSET = -20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 550;\nint START_Y = 400;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 4;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 8;",
            "offset": "int OFFSET = -20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 550;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 16;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 3;;\nint NUM_BRICKS_PER_ROW = 5;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 3;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 7;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 300 + 100;\nint START_Y = 100 + 350;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 300 + 100;",
            "startYPosition": "int START_Y = 100 + 350;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 300 + 100;\nint START_Y = 100 + 50;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 300 + 100;",
            "startYPosition": "int START_Y = 100 + 50;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 10;\nint ROGUE_BRICK_INDEX = 1;\nint START_X = 100 + 50;\nint START_Y = 100 + 400;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 1;",
            "startXPosition": "int START_X = 100 + 50;",
            "startYPosition": "int START_Y = 100 + 400;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 400;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nboolean isUpsideDown = true;\nString input = \"7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 400;",
            "numBricksBase": "7",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "5",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 30 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - (row + 1) * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.ORANGE);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "10",
            "offsetX": "int x = - 30 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - (row + 1) * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.RED);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-30",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.RED"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLUE);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-30",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 200;\nint START_Y = 550;\nint NUM_ROWS = 16;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = true;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "rightTriangle",
            "numBricksBase": "16",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 550;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 200;\nint START_Y = 500;\nint NUM_ROWS = 15;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "rightTriangle",
            "numBricksBase": "15",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 500;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 150;\nint START_Y = 550;\nint NUM_ROWS = 15;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = true;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "rightTriangle",
            "numBricksBase": "15",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "5",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 550;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-30",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 700; int y = 575;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = 700; int y = 575;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.RED);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.RED"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = -20;\n\n        // Optionally add centering assist lines\n        canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-20",
            "OFFSET_X": "20",
            "centeringAssistLines": "canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 10;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint OFFSET_X = 20;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "10",
            "brickWidth": "40",
            "brickHeight": "20",
            "OFFSET_Y": "-30",
            "OFFSET_X": "20",
            "centeringAssistLines": "canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 8;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 40;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 8;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "40",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = 10;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "10",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 150; int y = 450;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 20);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 150; int y = 450;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 20);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLUE);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 8;;\nint NUM_BRICKS_PER_ROW = 3;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 200;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 8;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 3;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 5;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 150; int y = 350;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 150; int y = 350;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 200;\nint START_Y = 500;\nint NUM_ROWS = 15;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "rightTriangle",
            "numBricksBase": "15",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 500;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 5;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 200;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 750; int y = 520;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = 750; int y = 520;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 550;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 16;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 550;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 4;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 650;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 4;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 650;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 8;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 150;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 7;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 8;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 150;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 7;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-30",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 10;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = -20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "10",
            "brickWidth": "40",
            "brickHeight": "10",
            "OFFSET_Y": "-20",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(true);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "20",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "20",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 200;\nint START_Y = 550;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 10;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 550;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 50;;\nint NUM_ROWS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = true;\nString input = \"5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "5",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 60;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x =   100 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 600 - row * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "20",
            "offsetX": "int x =   100 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 600 - row * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 3;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 200;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 7;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 10;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 3;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 200;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 7;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 10;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "// create aligned bricks in canvas \nimport acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 6;\nint NUM_ROWS = 40;\nint BRICK_WIDTH = 100;\nint BRICK_HEIGHT = 10;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                // 100 means the offset between outer and inner canvas\n                int x = 100 + col * BRICK_WIDTH; \n                int y = 100 + row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLACK);\n                canvas.add(brick);\n            }\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    \n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        canvas.paint(g);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramid_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// create aligned bricks in canvas \nimport acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                // 100 means the offset between outer and inner canvas\n                int x = 100 + col * BRICK_WIDTH; \n                int y = 100 + row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilledWall}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    \n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        canvas.paint(g);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramid_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "100",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 150;\nint START_Y = 350;\nint NUM_ROWS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nint HORIZONTAL_OFFSET = -20;\nint HOLE_PROBABILITY = 3;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 350;",
            "numBricksBase": "8",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "10",
            "horizontalOffset": "-20",
            "holeProbability": "3",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "20",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 200;\nint START_Y = 550;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = true;\nString input = \"6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 550;",
            "numBricksBase": "6",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "5",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "2",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(true);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 200;\nint START_Y = 550;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = false;\nString input = \"10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.ORANGE);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "trapezoid",
            "numBricksBase": "16",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 550;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 550;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 16;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 550;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = 450;\nint NUM_ROWS = 15;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "rightTriangle",
            "numBricksBase": "15",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 450;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 4;;\nint NUM_BRICKS_PER_ROW = 5;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 150;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 4;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 50;;\nint NUM_ROWS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "3",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 100; int y = 500;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 100; int y = 500;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 30 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 600 - row * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "10",
            "offsetX": "int x = - 30 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 600 - row * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 8;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 750;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 8;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x =   0 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - (row + 1) * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "10",
            "offsetX": "int x =   0 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - (row + 1) * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 3;;\nint NUM_BRICKS_PER_ROW = 5;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 750;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 3;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 50;\nint START_Y = 350;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 1;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 350;",
            "numBricksBase": "7",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "1",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100;\nint START_Y = 100;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100;",
            "startYPosition": "int START_Y = 100;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 7;;\nint OFFSET = -20;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 150;\nint START_Y = 500;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "offset": "int OFFSET = -20;",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 500;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 750;;\nint START_Y = 500;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 500;",
            "numBricksBase": "6",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 150; int y = 450;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 150; int y = 450;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 10;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 300 + 100;\nint START_Y = 100 + 450;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 300 + 100;",
            "startYPosition": "int START_Y = 100 + 450;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 50;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "6",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 7;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 30;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 650;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + 250;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 7;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "30",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 650;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 250;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 50;;\nint NUM_ROWS = 3;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.MAGENTA);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "3",
            "brickWidth": "20",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = 100 + 400;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 5;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"8, 8, 8, 8, 8, 8, 8, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 100 + 400;",
            "structure": "column",
            "numColumns": "8",
            "numBricksPerColumn": "constant",
            "brickWidth": "30",
            "brickHeight": "30",
            "brickSeparation": "5",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 7;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100 + 100;\nint START_Y = 100 + 400;\nint NUM_COLUMNS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"6, 6, 6, 6, 6, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 100 + 100;",
            "startY": "int START_Y = 100 + 400;",
            "structure": "column",
            "numColumns": "6",
            "numBricksPerColumn": "constant",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "5",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 200;\nint START_Y = 550;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = false;\nString input = \"10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.ORANGE);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "trapezoid",
            "numBricksBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 550;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 750;;\nint START_Y = 400;;\nint NUM_ROWS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nboolean isUpsideDown = true;\nString input = \"3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 400;",
            "numBricksBase": "3",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 10;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = 10;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "10",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "10",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = 100;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 15;\nboolean isUpsideDown = true;\nboolean isColumn = true;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 100;",
            "structure": "column",
            "numColumns": "8",
            "numBricksPerColumn": "varying",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "15",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 7;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 150;\nint START_Y = 500;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "20",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 500;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.RED);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.RED"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 7;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 1;\nint START_X = 150;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 1;",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 200;\nint START_Y = 400;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 10;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "10",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 6;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 650;\nint START_Y_FIRST_ROW = 450;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 7;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 6;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 650;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 450;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 7;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 50;;\nint NUM_ROWS = 4;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GREEN);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "4",
            "brickWidth": "20",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(true);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 16;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 2;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLUE);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 8;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 7;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 40;\nint BRICK_SEP_FIRST_ROW = 10;\nint ROGUE_BRICK_INDEX_FIRST_ROW = 1;\nint START_X_FIRST_ROW = 150;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 7;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 7;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "40",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 10;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = 1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 150;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 7;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 5;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 150;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 4;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 150;\nint START_Y_FIRST_ROW = 550;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 5;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 4;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 150;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 550;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 5;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 50;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = true;\nString input = \"6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.MAGENTA);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "6",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 200 + 100;\nint START_Y = 100;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 200 + 100;",
            "startYPosition": "int START_Y = 100;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 750;\nint START_Y = 450;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = false;\nString input = \"13, 12, 11, 10, 9, 8, 7, 6, 5, 4\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "trapezoid",
            "numBricksBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 450;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 16;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 5;;\nint NUM_BRICKS_PER_ROW = 5;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 150;\nint START_Y = 400;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 5;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 200;\nint START_Y = 550;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nboolean isUpsideDown = false;\nboolean isRightTriangle = false;\nString input = \"10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "trapezoid",
            "numBricksBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "10",
            "isUpsideDown": "false",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 550;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 300 + 100;\nint START_Y = 100 + 50;\nint NUM_COLUMNS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 15;\nboolean isUpsideDown = false;\nboolean isColumn = false;\nString input = \"4, 4, 4, 4\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 300 + 100;",
            "startY": "int START_Y = 100 + 50;",
            "structure": "diagonal",
            "numColumns": "4",
            "numBricksPerColumn": "constant",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "15",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = 10;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "10",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 300 + 100;\nint START_Y = 100 + 450;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 300 + 100;",
            "startYPosition": "int START_Y = 100 + 450;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 20;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 150; int y = 350;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 150; int y = 350;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 1;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 200;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 1;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 200; int y = 350;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 10, 30);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 200; int y = 350;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 10, 30);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 7;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = 500;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = false;\nString input = \"10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "trapezoid",
            "numBricksBase": "15",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 500;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 750;\nint START_Y = 50;\nint NUM_ROWS = 8;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 1;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "8",
            "brickWidth": "20",
            "brickHeight": "10",
            "brickSeparation": "10",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "1",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.RED);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.RED"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 200;\nint START_Y = 550;\nint NUM_ROWS = 16;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "rightTriangle",
            "numBricksBase": "16",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 550;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 150; int y = 450;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 20);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 150; int y = 450;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 20);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 150; int y = 350;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 150; int y = 350;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-30",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 75; int y = 100;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 40, 20);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = 75; int y = 100;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 40, 20);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 300 + 100;\nint START_Y = 100 + 400;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nboolean isUpsideDown = false;\nboolean isColumn = false;\nString input = \"8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 300 + 100;",
            "startY": "int START_Y = 100 + 400;",
            "structure": "diagonal",
            "numColumns": "8",
            "numBricksPerColumn": "varying",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "5",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 2;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "20",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 5;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 400;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 5;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 750;;\nint START_Y = 400;;\nint NUM_ROWS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 400;",
            "numBricksBase": "5",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 50;\nint START_Y = 550;\nint NUM_ROWS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 550;",
            "numBricksBase": "8",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "5",
            "horizontalOffset": "20",
            "holeProbability": "2",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-30",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLUE);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = 100 + 50;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"8, 8, 8, 8, 8, 8, 8, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 100 + 50;",
            "structure": "column",
            "numColumns": "8",
            "numBricksPerColumn": "constant",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "5",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 150;\nint START_Y = 50;\nint NUM_ROWS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "8",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "5",
            "horizontalOffset": "20",
            "holeProbability": "2",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 75; int y = 100;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = 75; int y = 100;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 10;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100 + 50;\nint START_Y = 100 + 400;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100 + 50;",
            "startYPosition": "int START_Y = 100 + 400;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 8;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 400;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 8;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 300; int y = 300;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 300; int y = 300;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 7;;\nint OFFSET = -20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 2;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 550;\nint START_Y = 500;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "offset": "int OFFSET = -20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 2;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 550;",
            "startY": "int START_Y = 500;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 50 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - row * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "10",
            "offsetX": "int x = - 50 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - row * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 5;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 200;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 5;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = 10;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "10",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 300 + 100;\nint START_Y = 100 + 300;\nboolean isDiagonal = false;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 300 + 100;",
            "startYPosition": "int START_Y = 100 + 300;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.RED);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.RED"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 300 + 100;\nint START_Y = 100 - 50;\nboolean isDiagonal = false;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 300 + 100;",
            "startYPosition": "int START_Y = 100 - 50;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 50;\nint START_Y = 350;\nint NUM_ROWS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLUE);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 350;",
            "numBricksBase": "8",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "2",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 300 + 100;\nint START_Y = 100 + 50;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nboolean isUpsideDown = true;\nboolean isColumn = true;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 300 + 100;",
            "startY": "int START_Y = 100 + 50;",
            "structure": "column",
            "numColumns": "8",
            "numBricksPerColumn": "varying",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "5",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 30 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 600 - (row + 1) * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "10",
            "offsetX": "int x = - 30 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 600 - (row + 1) * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 150; int y = 350;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 10, 30);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 150; int y = 350;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 10, 30);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(true);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 300 + 100;\nint START_Y = 100 + 100;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 5;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"8, 8, 8, 8, 8, 8, 8, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 300 + 100;",
            "startY": "int START_Y = 100 + 100;",
            "structure": "column",
            "numColumns": "8",
            "numBricksPerColumn": "constant",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "5",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 8;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 0;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 7;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 8;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 0;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 7;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 50; int y = 50;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = 50; int y = 50;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 8;;\nint OFFSET = -20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 150;\nint START_Y = 500;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 8;",
            "offset": "int OFFSET = -20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 500;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 5;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 5;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 150;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 5;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 5;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 5;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 150;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 5;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 4;;\nint NUM_BRICKS_PER_ROW = 8;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 4;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 8;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 4;;\nint NUM_BRICKS_PER_ROW = 4;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 2;\nint START_X = 50;\nint START_Y = 500;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 4;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 4;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 2;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 500;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 150;;\nint START_Y = 550;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 550;",
            "numBricksBase": "7",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "5",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = 20;\n\n        // Optionally add centering assist lines\n        canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "20",
            "OFFSET_X": "40",
            "centeringAssistLines": "canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 750;\nint START_Y = 50;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "6",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "2",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = 50;\nint NUM_ROWS = 16;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "rightTriangle",
            "numBricksBase": "16",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 8;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 8;",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 2;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 200;\nint START_Y = 550;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 2;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 550;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 4;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 300 + 100;\nint START_Y = 100 + 400;\nboolean isDiagonal = false;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 4;",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 300 + 100;",
            "startYPosition": "int START_Y = 100 + 400;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = 10;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "10",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 200 + 100;\nint START_Y = 100 + 350;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 10;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"8, 8, 8, 8, 8, 8, 8, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 200 + 100;",
            "startY": "int START_Y = 100 + 350;",
            "structure": "column",
            "numColumns": "8",
            "numBricksPerColumn": "constant",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "10",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "10",
            "OFFSET_Y": "-30",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.RED);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.RED"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100 + 50;\nint START_Y = 100 + 400;\nboolean isDiagonal = false;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 4;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100 + 50;",
            "startYPosition": "int START_Y = 100 + 400;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 750;;\nint START_Y = 500;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 500;",
            "numBricksBase": "7",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 100 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - row * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "10",
            "offsetX": "int x = - 100 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - row * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 400;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 400;",
            "numBricksBase": "7",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 750; int y = 520;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = 750; int y = 520;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 200;\nint START_Y = 450;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = false;\nString input = \"10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "trapezoid",
            "numBricksBase": "16",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 450;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 8;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 150;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 8;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 150;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 8;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 2;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 550;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 8;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "20",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 2;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 550;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 20;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = 20;\n\n        // Optionally add centering assist lines\n        canvas.add(new GLine(canvas.getWidth() / 2, 0, canvas.getWidth() / 2, canvas.getHeight()));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "20",
            "OFFSET_X": "40",
            "centeringAssistLines": "canvas.add(new GLine(canvas.getWidth() / 2, 0, canvas.getWidth() / 2, canvas.getHeight()));",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 150; int y = 350;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 150; int y = 350;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "10",
            "OFFSET_Y": "-30",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 7;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 500;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 500;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100;\nint START_Y = 100 + 400;\nboolean isDiagonal = false;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100;",
            "startYPosition": "int START_Y = 100 + 400;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-30",
            "OFFSET_X": "20",
            "centeringAssistLines": "canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(true);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 10;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = 10;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "10",
            "brickWidth": "40",
            "brickHeight": "10",
            "OFFSET_Y": "10",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 750;\nint START_Y = 550;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = false;\nString input = \"15, 14, 13, 12, 11, 10, 9, 8, 7, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "trapezoid",
            "numBricksBase": "15",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 550;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.RED);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.RED"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100;\nint START_Y = 100 + 450;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100;",
            "startYPosition": "int START_Y = 100 + 450;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 400;;\nint NUM_ROWS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 400;",
            "numBricksBase": "4",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 26;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 60;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 30 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - row * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(true);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "60",
            "brickHeight": "10",
            "offsetX": "int x = - 30 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - row * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 4;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 750;\nint START_Y = 550;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 4;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 550;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 100 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 600 - (row + 1) * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "10",
            "offsetX": "int x = - 100 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 600 - (row + 1) * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-30",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint OFFSET_X = 40;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "20",
            "OFFSET_Y": "-30",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 7;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 150;\nint START_Y = 400;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 300 + 100;\nint START_Y = 100 + 350;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nboolean isUpsideDown = true;\nboolean isColumn = true;\nString input = \"8, 8, 8, 8, 8, 8, 8, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 300 + 100;",
            "startY": "int START_Y = 100 + 350;",
            "structure": "column",
            "numColumns": "8",
            "numBricksPerColumn": "constant",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickSeparation": "5",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 16;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 200;;\nint START_Y = 400;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = true;\nString input = \"6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 400;",
            "numBricksBase": "6",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "10",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 400;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 400;",
            "numBricksBase": "7",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x =   100 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - row * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "10",
            "offsetX": "int x =   100 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - row * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 150;\nint START_Y = 500;\nint NUM_ROWS = 15;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "rightTriangle",
            "numBricksBase": "15",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 500;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 3;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 200;\nint START_Y = 550;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 3;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 550;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 550;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nboolean isUpsideDown = true;\nString input = \"7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GREEN);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 550;",
            "numBricksBase": "7",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 300; int y = 300;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 300; int y = 300;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 4;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 400;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 4;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 550;;\nint NUM_ROWS = 5;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.ORANGE);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 550;",
            "numBricksBase": "5",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 1;\nint START_X = 100 - 50;\nint START_Y = 100 + 400;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 1;",
            "startXPosition": "int START_X = 100 - 50;",
            "startYPosition": "int START_Y = 100 + 400;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 750;\nint START_Y = 550;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 3;\nboolean isUpsideDown = true;\nString input = \"6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 550;",
            "numBricksBase": "6",
            "brickWidth": "20",
            "brickHeight": "10",
            "brickSeparation": "5",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "3",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        canvas.add(new GLine(canvas.getWidth() / 2, 0, canvas.getWidth() / 2, canvas.getHeight()));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-30",
            "OFFSET_X": "40",
            "centeringAssistLines": "canvas.add(new GLine(canvas.getWidth() / 2, 0, canvas.getWidth() / 2, canvas.getHeight()));",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 60; int y = 550;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = 60; int y = 550;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 16;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 16;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint OFFSET_X = 40;\nint OFFSET_Y = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "20",
            "OFFSET_Y": "20",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 7;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = 2;\nint START_X_FIRST_ROW = 0;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + 250;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 7;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = 2;",
            "startXFirstRow": "int START_X_FIRST_ROW = 0;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 250;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.MAGENTA);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 8;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 50 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - row * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLUE);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "10",
            "offsetX": "int x = - 50 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - row * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 5;;\nint NUM_BRICKS_PER_ROW = 6;;\nint OFFSET = -20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 150;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 5;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "offset": "int OFFSET = -20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 20;\nint NUM_ROWS = 30;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 40;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 50 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - (row + 1) * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "80",
            "brickHeight": "40",
            "offsetX": "int x = - 50 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - (row + 1) * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = 20;\n\n        // Optionally add centering assist lines\n        canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "20",
            "OFFSET_X": "40",
            "centeringAssistLines": "canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        canvas.add(new GLine(canvas.getWidth() / 2, 0, canvas.getWidth() / 2, canvas.getHeight()));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-30",
            "OFFSET_X": "40",
            "centeringAssistLines": "canvas.add(new GLine(canvas.getWidth() / 2, 0, canvas.getWidth() / 2, canvas.getHeight()));",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 5;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 550;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 5;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 550;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 15;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 300;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 5;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 15;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 300;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 5;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 8;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 650;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 3;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 8;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 650;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 3;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 50; int y = 50;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = 50; int y = 50;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 150;\nint START_Y = 550;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 1;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 550;",
            "numBricksBase": "7",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "10",
            "horizontalOffset": "20",
            "holeProbability": "1",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 10;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = 10;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "10",
            "brickWidth": "40",
            "brickHeight": "10",
            "OFFSET_Y": "10",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 4;;\nint NUM_BRICKS_PER_ROW = 5;;\nint OFFSET = -20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 2;\nint START_X = 550;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 4;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "offset": "int OFFSET = -20;",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 2;",
            "startX": "int START_X = 550;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 5;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 150;\nint START_Y = 550;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 5;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 550;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 300 + 100;\nint START_Y = 100;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 10;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"8, 8, 8, 8, 8, 8, 8, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 300 + 100;",
            "startY": "int START_Y = 100;",
            "structure": "column",
            "numColumns": "8",
            "numBricksPerColumn": "constant",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "10",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 3;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 150;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 3;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100;\nint START_Y = 100 + 300;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100;",
            "startYPosition": "int START_Y = 100 + 300;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 3;;\nint NUM_BRICKS_PER_ROW = 8;;\nint OFFSET = -20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 200;\nint START_Y = 550;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.GREEN);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 3;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 8;",
            "offset": "int OFFSET = -20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 550;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 300 + 100;\nint START_Y = 100 - 50;\nboolean isDiagonal = false;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 300 + 100;",
            "startYPosition": "int START_Y = 100 - 50;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 15;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 200;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 4;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 15;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 200;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 4;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "20",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 6;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 5;\nint ROGUE_BRICK_INDEX_FIRST_ROW = 2;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 7;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 30;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 6;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 5;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = 2;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 7;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "30",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint OFFSET_X = 20;\nint OFFSET_Y = -20;\n\n        // Optionally add centering assist lines\n        canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "20",
            "OFFSET_Y": "-20",
            "OFFSET_X": "20",
            "centeringAssistLines": "canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 200;\nint START_Y = 350;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 1;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 350;",
            "numBricksBase": "6",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "1",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = -20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-20",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100 + 50;\nint START_Y = 100 + 100;\nboolean isDiagonal = false;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100 + 50;",
            "startYPosition": "int START_Y = 100 + 100;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.RED);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.RED"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 6;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 200;\nint START_Y = 550;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 550;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 750;;\nint START_Y = 550;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.ORANGE);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 550;",
            "numBricksBase": "6",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 150; int y = 350;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        rect.setFilled(true); rect.setColor(Color.YELLOW);\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 150; int y = 350;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "rect.setFilled(true); rect.setColor(Color.YELLOW);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 3;;\nint NUM_BRICKS_PER_ROW = 4;;\nint OFFSET = -20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 150;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 3;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 4;",
            "offset": "int OFFSET = -20;",
            "brickWidth": "30",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(true);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 10;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 8;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 4;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 1;\nint START_X = 200;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.RED);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 4;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.RED"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 16;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 150;;\nint START_Y = 500;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 500;",
            "numBricksBase": "6",
            "brickWidth": "30",
            "brickHeight": "30",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 100 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 600 - (row + 1) * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "10",
            "offsetX": "int x = - 100 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 600 - (row + 1) * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 150;\nint START_Y = 50;\nint NUM_ROWS = 15;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = true;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "rightTriangle",
            "numBricksBase": "15",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100 - 50;\nint START_Y = 100 + 300;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100 - 50;",
            "startYPosition": "int START_Y = 100 + 300;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 90 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - row * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "10",
            "offsetX": "int x = - 90 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - row * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 750;\nint START_Y = 400;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 5;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 40;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 150;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 3;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 5;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "40",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 150;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 3;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100;\nint START_Y = 100 + 400;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 4;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100;",
            "startYPosition": "int START_Y = 100 + 400;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 2;\nint START_Y = 50;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 7;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startYPosition": "int START_Y = 50;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 300; int y = 300;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 300; int y = 300;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 200;;\nint START_Y = 400;;\nint NUM_ROWS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nboolean isUpsideDown = true;\nString input = \"3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 400;",
            "numBricksBase": "3",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "20",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = -20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "10",
            "OFFSET_Y": "-20",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 750;\nint START_Y = 500;\nint NUM_ROWS = 16;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.ORANGE);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "rightTriangle",
            "numBricksBase": "16",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 500;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 300 + 100;\nint START_Y = 100 + 350;\nint NUM_COLUMNS = 5;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"5, 5, 5, 5, 5\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 300 + 100;",
            "startY": "int START_Y = 100 + 350;",
            "structure": "column",
            "numColumns": "5",
            "numBricksPerColumn": "constant",
            "brickWidth": "20",
            "brickHeight": "10",
            "brickSeparation": "5",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 200;\nint START_Y = 510;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = true;\nString input = \"7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 510;",
            "numBricksBase": "7",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "holeProbability": "2",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = -20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-20",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint OFFSET_X = 20;\nint OFFSET_Y = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "20",
            "OFFSET_Y": "20",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(true);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100 + 100;\nint START_Y = 100;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100 + 100;",
            "startYPosition": "int START_Y = 100;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 3;;\nint NUM_BRICKS_PER_ROW = 3;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 200;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 3;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 3;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 5;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLUE);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-30",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 750;\nint START_Y = 510;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = true;\nString input = \"7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 510;",
            "numBricksBase": "7",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "2",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint OFFSET_X = 40;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "20",
            "OFFSET_Y": "-30",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 200;\nint START_Y = 50;\nint NUM_ROWS = 15;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "rightTriangle",
            "numBricksBase": "15",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = 10;\n\n        // Optionally add centering assist lines\n        canvas.add(new GLine(canvas.getWidth() / 2, 0, canvas.getWidth() / 2, canvas.getHeight()));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "10",
            "OFFSET_X": "40",
            "centeringAssistLines": "canvas.add(new GLine(canvas.getWidth() / 2, 0, canvas.getWidth() / 2, canvas.getHeight()));",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 5;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 150;\nint START_Y = 550;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 550;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 8;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 8;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 5;;\nint NUM_BRICKS_PER_ROW = 5;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 200;\nint START_Y = 550;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 5;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 550;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 3;;\nint NUM_BRICKS_PER_ROW = 7;;\nint OFFSET = -20;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 550;\nint START_Y = 550;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 3;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "offset": "int OFFSET = -20;",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 550;",
            "startY": "int START_Y = 550;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 15;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 30;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 300;\nint START_Y_FIRST_ROW = 350;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 6;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 15;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "30",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 300;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 350;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 6;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 5;;\nint NUM_BRICKS_PER_ROW = 8;;\nint OFFSET = -20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 2;\nint START_X = 200;\nint START_Y = 400;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 5;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 8;",
            "offset": "int OFFSET = -20;",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 2;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 250;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 250;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 150; int y = 450;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 150; int y = 450;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 3;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = 550;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 3;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 10;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 3;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 550;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 3;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 10;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 75; int y = 100;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = 75; int y = 100;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 200; int y = 350;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 200; int y = 350;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = 20;\n\n        // Optionally add centering assist lines\n        canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.RED);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "20",
            "OFFSET_X": "20",
            "centeringAssistLines": "canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.RED"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 10;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "10",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = 100 + 100;\nint NUM_COLUMNS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"7, 7, 7, 7, 7, 7, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 100 + 100;",
            "structure": "column",
            "numColumns": "7",
            "numBricksPerColumn": "constant",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "5",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 175; int y = 275;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 175; int y = 275;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 750;\nint START_Y = 350;\nint NUM_ROWS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 350;",
            "numBricksBase": "5",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "2",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = -20;\n\n        // Optionally add centering assist lines\n        canvas.add(new GLine(canvas.getWidth() / 2, 0, canvas.getWidth() / 2, canvas.getHeight()));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-20",
            "OFFSET_X": "40",
            "centeringAssistLines": "canvas.add(new GLine(canvas.getWidth() / 2, 0, canvas.getWidth() / 2, canvas.getHeight()));",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 150;\nint START_Y = 450;\nint NUM_ROWS = 16;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "rightTriangle",
            "numBricksBase": "16",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 450;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100 + 100;\nint START_Y = 100 + 350;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 15;\nboolean isUpsideDown = true;\nboolean isColumn = false;\nString input = \"8, 8, 8, 8, 8, 8, 8, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 100 + 100;",
            "startY": "int START_Y = 100 + 350;",
            "structure": "diagonal",
            "numColumns": "8",
            "numBricksPerColumn": "constant",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "15",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 6;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 3;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 6;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 3;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 5;;\nint NUM_BRICKS_PER_ROW = 7;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 2;\nint START_X = 50;\nint START_Y = 550;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 5;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 2;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 550;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 400;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100 + 50;\nint START_Y = 100 - 50;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 15;\nboolean isUpsideDown = true;\nboolean isColumn = false;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 100 + 50;",
            "startY": "int START_Y = 100 - 50;",
            "structure": "diagonal",
            "numColumns": "8",
            "numBricksPerColumn": "varying",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "15",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "20",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 100; int y = 500;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 100; int y = 500;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 300 + 100;\nint START_Y = 100 + 400;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 15;\nboolean isUpsideDown = false;\nboolean isColumn = false;\nString input = \"8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 300 + 100;",
            "startY": "int START_Y = 100 + 400;",
            "structure": "diagonal",
            "numColumns": "8",
            "numBricksPerColumn": "varying",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "15",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "40",
            "brickHeight": "10",
            "OFFSET_Y": "-30",
            "OFFSET_X": "20",
            "centeringAssistLines": "canvas.add(new GLine(0, canvas.getHeight() / 2, canvas.getWidth(), canvas.getHeight() / 2));",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 50;\nint START_Y = 510;\nint NUM_ROWS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = true;\nString input = \"8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 510;",
            "numBricksBase": "8",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "10",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "holeProbability": "2",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = -20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-20",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 8;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 150;\nint START_Y = 400;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 8;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 90 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - row * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "10",
            "offsetX": "int x = - 90 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - row * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = 10;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.RED);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "10",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.RED"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 300 + 100;\nint START_Y = 100 + 400;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"8, 8, 8, 8, 8, 8, 8, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 300 + 100;",
            "startY": "int START_Y = 100 + 400;",
            "structure": "column",
            "numColumns": "8",
            "numBricksPerColumn": "constant",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "5",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 100; int y = 500;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 100; int y = 500;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 750;\nint START_Y = 550;\nint NUM_ROWS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 550;",
            "numBricksBase": "4",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "10",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "holeProbability": "2",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 300 + 100;\nint START_Y = 100 + 50;\nboolean isDiagonal = false;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 300 + 100;",
            "startYPosition": "int START_Y = 100 + 50;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 150; int y = 350;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 10, 30);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 150; int y = 350;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 10, 30);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100;\nint START_Y = 100 - 50;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100;",
            "startYPosition": "int START_Y = 100 - 50;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 300 + 100;\nint START_Y = 100 + 350;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 15;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"8, 8, 8, 8, 8, 8, 8, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 300 + 100;",
            "startY": "int START_Y = 100 + 350;",
            "structure": "column",
            "numColumns": "8",
            "numBricksPerColumn": "constant",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "15",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 200;\nint START_Y = 550;\nint NUM_ROWS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 3;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 550;",
            "numBricksBase": "8",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "3",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = 10;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "10",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 200 + 100;\nint START_Y = 100;\nboolean isDiagonal = false;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 200 + 100;",
            "startYPosition": "int START_Y = 100;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100 + 100;\nint START_Y = 100 + 300;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 4;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100 + 100;",
            "startYPosition": "int START_Y = 100 + 300;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 150;\nint START_Y = 50;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "6",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "2",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 150;;\nint START_Y = 400;;\nint NUM_ROWS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 400;",
            "numBricksBase": "4",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 175; int y = 275;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 175; int y = 275;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 13;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 120;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 100 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - row * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "120",
            "brickHeight": "10",
            "offsetX": "int x = - 100 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - row * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 200;\nint START_Y = 500;\nint NUM_ROWS = 15;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = true;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.RED);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "rightTriangle",
            "numBricksBase": "15",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 500;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.RED"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = -20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.RED);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-20",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.RED"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 50; int y = 50;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = 50; int y = 50;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GREEN);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "20",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 1;\nint START_X = 50;\nint START_Y = 400;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint OFFSET_X = 20;\nint OFFSET_Y = -20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "OFFSET_Y": "-20",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = -20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLUE);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-20",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nint ROGUE_BRICK_INDEX = 1;\nint START_X = 100 + 50;\nint START_Y = 100 + 350;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 4;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 1;",
            "startXPosition": "int START_X = 100 + 50;",
            "startYPosition": "int START_Y = 100 + 350;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 750;;\nint START_Y = 400;;\nint NUM_ROWS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 400;",
            "numBricksBase": "5",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = 50;\nint NUM_ROWS = 16;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "rightTriangle",
            "numBricksBase": "16",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 5;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 200;\nint START_Y = 500;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 500;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "// create aligned bricks in canvas \nimport acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 20;\nint NUM_ROWS = 40;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                // 100 means the offset between outer and inner canvas\n                int x = 100 + col * BRICK_WIDTH; \n                int y = 100 + row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLACK);\n                canvas.add(brick);\n            }\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    \n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        canvas.paint(g);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramid_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// create aligned bricks in canvas \nimport acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                // 100 means the offset between outer and inner canvas\n                int x = 100 + col * BRICK_WIDTH; \n                int y = 100 + row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilledWall}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    \n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        canvas.paint(g);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramid_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 50;\nint START_Y = 550;\nint NUM_ROWS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 3;\nboolean isUpsideDown = true;\nString input = \"8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.GRAY);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 550;",
            "numBricksBase": "8",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "5",
            "horizontalOffset": "20",
            "holeProbability": "3",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 30 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - row * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "10",
            "offsetX": "int x = - 30 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - row * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 3;;\nint NUM_BRICKS_PER_ROW = 5;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 1;\nint START_X = 200;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 3;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "brickWidth": "30",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 10;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 6;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 0;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 4;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 10;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 6;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 0;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 4;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 10;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = -20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-20",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 3;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 200;\nint START_Y = 550;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 3;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 550;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 550;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 8;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 550;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 60; int y = 550;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = 60; int y = 550;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 2;\nint START_X = 300 + 100;\nint START_Y = 100 + 350;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLUE);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 4;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startXPosition": "int START_X = 300 + 100;",
            "startYPosition": "int START_Y = 100 + 350;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 75; int y = 100;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = 75; int y = 100;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 750;\nint START_Y = 50;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = true;\nString input = \"6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.GRAY);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "6",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "holeProbability": "2",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLUE);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = 10;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "10",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 5;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 200;\nint START_Y = 500;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 500;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickFilled": "brick.setFilled(true);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 10;\nint ROGUE_BRICK_INDEX = 2;\nint START_X = 100 + 100;\nint START_Y = 100 + 50;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 4;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startXPosition": "int START_X = 100 + 100;",
            "startYPosition": "int START_Y = 100 + 50;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 8;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 300 + 100;\nint START_Y = 100 + 350;\nint NUM_COLUMNS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 300 + 100;",
            "startY": "int START_Y = 100 + 350;",
            "structure": "column",
            "numColumns": "5",
            "numBricksPerColumn": "varying",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "5",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 15;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 150;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 6;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 5;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 15;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 150;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 6;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 5;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 300; int y = 300;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 300; int y = 300;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 150;;\nint START_Y = 400;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 400;",
            "numBricksBase": "7",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 150; int y = 350;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 150; int y = 350;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 300 + 100;\nint START_Y = 100 + 50;\nint NUM_COLUMNS = 4;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"column_structure_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 300 + 100;",
            "startY": "int START_Y = 100 + 50;",
            "structure": "column",
            "numColumns": "4",
            "numBricksPerColumn": "varying",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickSeparation": "5",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 50; int y = 50;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = 50; int y = 50;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 150; int y = 450;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 150; int y = 450;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 750;\nint START_Y = 50;\nint NUM_ROWS = 14;\nint NUM_BRICKS_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nboolean isUpsideDown = true;\nboolean isRightTriangle = true;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "rightTriangle",
            "numBricksBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "5",
            "isUpsideDown": "true",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "20",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 6;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 400;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 7;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 6;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 6;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 6;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 6;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100 + 50;\nint START_Y = 100 + 100;\nboolean isDiagonal = false;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100 + 50;",
            "startYPosition": "int START_Y = 100 + 100;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 20;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 2;\nint START_Y = 550;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startYPosition": "int START_Y = 550;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 90 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - row * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "10",
            "offsetX": "int x = - 90 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - row * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint OFFSET_X = 40;\nint OFFSET_Y = 10;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "20",
            "OFFSET_Y": "10",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 750;;\nint START_Y = 500;;\nint NUM_ROWS = 3;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 500;",
            "numBricksBase": "3",
            "brickWidth": "20",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100;\nint START_Y = 100 + 450;\nboolean isDiagonal = false;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 4;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100;",
            "startYPosition": "int START_Y = 100 + 450;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = true;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "20",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 26;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 60;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 90 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - (row + 1) * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "60",
            "brickHeight": "10",
            "offsetX": "int x = - 90 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - (row + 1) * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 150;\nint START_Y = 450;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = false;\nString input = \"16, 15, 14, 13, 12, 11, 10, 9, 8, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "trapezoid",
            "numBricksBase": "16",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 450;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 7;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 150;\nint START_Y = 550;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 550;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLUE);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 13;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 120;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 90 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - row * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "120",
            "brickHeight": "10",
            "offsetX": "int x = - 90 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - row * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 200;\nint START_Y = 550;\nint NUM_ROWS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 10;\nint ROW_SEP = 5;\nint HORIZONTAL_OFFSET = -20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 550;",
            "numBricksBase": "8",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "10",
            "rowSeparation": "5",
            "horizontalOffset": "-20",
            "holeProbability": "2",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "20",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = 10;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "10",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 8;;\nint NUM_BRICKS_PER_ROW = 5;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 550;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 8;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "brickWidth": "30",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 550;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 8;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 8;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 550;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = true;\nString input = \"7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 550;",
            "numBricksBase": "7",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 750;\nint START_Y = 50;\nint NUM_ROWS = 3;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 3;\nboolean isUpsideDown = true;\nString input = \"3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "3",
            "brickWidth": "20",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "10",
            "horizontalOffset": "20",
            "holeProbability": "3",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 8;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 150;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 7;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 8;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 150;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 7;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 4;;\nint NUM_BRICKS_PER_ROW = 6;;\nint OFFSET = -20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 200;\nint START_Y = 500;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 4;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "offset": "int OFFSET = -20;",
            "brickWidth": "30",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 500;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 750;\nint START_Y = 400;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 8;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 750;\nint START_Y = 400;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 8;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 150; int y = 450;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 150; int y = 450;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 200;\nint START_Y = 450;\nint NUM_ROWS = 16;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"right_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "shape": "rightTriangle",
            "numBricksBase": "16",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 450;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 150;;\nint START_Y = 500;;\nint NUM_ROWS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 500;",
            "numBricksBase": "5",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "5",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = -20;\n\n        // Optionally add centering assist lines\n        canvas.add(new GLine(canvas.getWidth() / 2, 0, canvas.getWidth() / 2, canvas.getHeight()));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-20",
            "OFFSET_X": "40",
            "centeringAssistLines": "canvas.add(new GLine(canvas.getWidth() / 2, 0, canvas.getWidth() / 2, canvas.getHeight()));",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 150; int y = 450;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 150; int y = 450;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-30",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.RED);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.RED"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 750;;\nint START_Y = 500;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nboolean isUpsideDown = true;\nString input = \"7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 500;",
            "numBricksBase": "7",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "5",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100 - 50;\nint START_Y = 100 + 50;\nboolean isDiagonal = false;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                {SetBrickFilledWall}\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"diagonal_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100 - 50;",
            "startYPosition": "int START_Y = 100 + 50;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = false;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 50;\nint START_Y = 350;\nint NUM_ROWS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = true;\nString input = \"8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 350;",
            "numBricksBase": "8",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "holeProbability": "2",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 8;",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 400;;\nint NUM_ROWS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint HORIZONTAL_OFFSET = -20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"scalene_triangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 400;",
            "numBricksBase": "3",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "5",
            "horizontalOffset": "-20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 60; int y = 550;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 30, 10);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"hello_world_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = 60; int y = 550;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 30, 10);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 5;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 200;\nint START_Y = 400;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetBrickFilledWall}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    {SetBrickFilledWall}\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"rectangle_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 5;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 200;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 20;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 20;",
            "brickWidth": "30",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 15;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 300;\nint START_Y_FIRST_ROW = 550;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 3;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 15;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 300;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 550;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 3;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 5;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 10;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 200;\nint START_Y_FIRST_ROW = 500;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 7;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 10;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"two_rows_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 5;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "10",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 200;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 500;",
            "brickColor": "Color.GRAY",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 7;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "10",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW - BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "20",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 6;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 150;\nint START_Y = 400;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"parallelogram_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 400;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 150;\nint START_Y = 510;\nint NUM_ROWS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 150;",
            "startY": "int START_Y = 510;",
            "numBricksBase": "5",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "5",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "2",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = -20;\n\n        // Optionally add centering assist lines\n        canvas.add(new GLine(canvas.getWidth() / 2, 0, canvas.getWidth() / 2, canvas.getHeight()));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_pyramid_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-20",
            "OFFSET_X": "40",
            "centeringAssistLines": "canvas.add(new GLine(canvas.getWidth() / 2, 0, canvas.getWidth() / 2, canvas.getHeight()));",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLUE);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "10",
            "OFFSET_Y": "20",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 40;\nint OFFSET_Y = -20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "13",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-20",
            "OFFSET_X": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 450;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLUE);\n            }\n\n            canvas.add(brick);\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = 100 + i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"single_row_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "numBricks": "int NUM_BRICKS = 8;",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 450;",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 750;\nint START_Y = 50;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 1;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"pyramid_like_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "startX": "int START_X = 750;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "7",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "1",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"perfect_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "11",
            "brickWidth": "30",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\nint OFFSET_X = 20;\nint OFFSET_Y = -30;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramidOffset}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + 500 - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (800 - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n        \n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"offset_extra_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "bricksInBase": "12",
            "brickWidth": "30",
            "brickHeight": "10",
            "OFFSET_Y": "-30",
            "OFFSET_X": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    int NUM_COLUMNS = 53;\nint NUM_ROWS = 120;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 10;\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {\n                        for (int col = 0; col < NUM_COLUMNS; col++) {\n                            // 100 means the offset between outer and inner canvas\n                            int x = - 100 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);\n                            int y = 500 - row * BRICK_HEIGHT; \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            brick.setFilled(false);\n    \n                            brick.setColor(Color.BLACK);\n                            canvas.add(brick);\n                        }\n                    }\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "// Create offset bricks for even and odd rows\n            import acm.graphics.*;\n            import java.awt.Color;\n            import java.awt.Graphics;\n            import java.awt.image.BufferedImage;\n            import java.io.File;\n            import java.text.SimpleDateFormat;\n            import java.util.Date;\n            import javax.imageio.ImageIO;\n    \n            public class DrawStructure{{\n                private static final int INNER_CANVAS_WIDTH = 600;\n                private static final int INNER_CANVAS_HEIGHT = 400;\n                private static final int OUTER_CANVAS_WIDTH = 800;\n                private static final int OUTER_CANVAS_HEIGHT = 600;\n    \n                public static void main(String[] args) {{\n                    // Create an off-screen GCanvas\n                    GCanvas canvas = new GCanvas();\n                    canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Initialize structure parameters\n                    {InitializeStructureParametersBrickWallWholeScreen}\n    \n                    // Draw rows of bricks covering the entire screen without offset\n                    for (int row = 0; row < NUM_ROWS; row++) {{\n                        for (int col = 0; col < NUM_COLUMNS; col++) {{\n                            // 100 means the offset between outer and inner canvas\n                            {WallXFullScreen}\n                            {WallYFullScreen} \n                            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n    \n                            // Determine if the brick is filled\n                            {SetBrickFilledWall}\n    \n                            brick.setColor({BrickColorBrickWall});\n                            canvas.add(brick);\n                        }}\n                    }}\n    \n                    // Draw the inner canvas boundary\n                    GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                                           (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                                           INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n                    innerCanvasBoundary.setColor(Color.BLACK);\n                    canvas.add(innerCanvasBoundary);\n    \n                    // Save the canvas as an image\n                    saveCanvasAsImage(canvas);\n                }}\n    \n                private static void saveCanvasAsImage(GCanvas canvas) {{\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n    \n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n    \n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"brick_wall_\" + timestamp + \".png\";\n    \n                    try {{\n                        // Write the buffered image to a file\n                        ImageIO.write(image, \"png\", new File(filename));\n                        System.out.println(\"Image saved as \" + filename);\n                    }} catch (Exception e) {{\n                        e.printStackTrace();\n                    }}\n                }}            \n            }}",
            "brickWidth": "30",
            "brickHeight": "10",
            "offsetX": "int x = - 100 + col * BRICK_WIDTH + (row % 2 == 0 ? 0: BRICK_WIDTH / 2);",
            "offsetY": "int y = 500 - row * BRICK_HEIGHT;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    }
]