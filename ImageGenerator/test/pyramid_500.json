[
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 7;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 30;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = 2;\nint START_X_FIRST_ROW = -100;\nint START_Y_FIRST_ROW = -150;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.MAGENTA);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 3;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 40;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.MAGENTA);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 7;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "30",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = 2;",
            "startXFirstRow": "int START_X_FIRST_ROW = -100;",
            "startYFirstRow": "int START_Y_FIRST_ROW = -150;",
            "brickColor": "Color.MAGENTA",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 3;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "40",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;\nint START_Y = -50;\nint NUM_COLUMNS = 3;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 5;\nboolean isUpsideDown = true;\nboolean isColumn = false;\nString input = \"3, 3, 3\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "structure": "diagonal",
            "numColumns": "3",
            "numBricksPerColumn": "constant",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "5",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLUE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = -50;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nboolean isUpsideDown = true;\nboolean isColumn = true;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "structure": "column",
            "numColumns": "8",
            "numBricksPerColumn": "varying",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "0",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 150; int y = 150;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 75, 150);\n        // Add color, optional \n        rect.setFilled(true); rect.setColor(Color.BLUE);\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 150; int y = 150;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 75, 150);",
            "rectangleColor": "rect.setFilled(true); rect.setColor(Color.BLUE);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 5;;\nint NUM_BRICKS_PER_ROW = 4;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = -50;\nint START_Y = 50;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 5;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 4;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 8;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 1;\nint ROGUE_DIAGONAL_INDEX = 2;\nint START_X = -50;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.YELLOW);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 8;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 2;",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = 50;\nint NUM_COLUMNS = 7;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"7, 7, 7, 7, 7, 7, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "structure": "column",
            "numColumns": "7",
            "numBricksPerColumn": "constant",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "0",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 4;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = -50;\nint START_Y = 100;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.YELLOW);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 4;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(true);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 50;\nint START_Y = 50;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.GREEN);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "6",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "10",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "2",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;;\nint START_Y = 100;;\nint NUM_ROWS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROW_SEP = 5;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 100;",
            "numBricksBase": "3",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "10",
            "rowSeparation": "5",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;\nint START_Y = 50;\nint NUM_COLUMNS = 3;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nboolean isUpsideDown = true;\nboolean isColumn = false;\nString input = \"1, 2, 3\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.MAGENTA);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "structure": "diagonal",
            "numColumns": "3",
            "numBricksPerColumn": "varying",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "0",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 8;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 40;\nint BRICK_SEP_FIRST_ROW = 5;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = -100;\nint START_Y_FIRST_ROW = 100;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 20;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 8;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "40",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 5;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = -100;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 100;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "20",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 8;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 100;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.GRAY);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 8;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 5;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(true);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = -50;\nint START_Y = -50;\nint NUM_ROWS = 16;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = true;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "16",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = -50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 10;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "10",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = -50;\nint NUM_COLUMNS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nboolean isUpsideDown = true;\nboolean isColumn = false;\nString input = \"7, 7, 7, 7, 7, 7, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "structure": "diagonal",
            "numColumns": "7",
            "numBricksPerColumn": "constant",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "0",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 10;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "10",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;\nint START_Y = 100;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nboolean isUpsideDown = false;\nboolean isColumn = false;\nString input = \"8, 8, 8, 8, 8, 8, 8, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GREEN);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 100;",
            "structure": "diagonal",
            "numColumns": "8",
            "numBricksPerColumn": "constant",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 5;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 1;\nint START_X = 50;\nint START_Y = 100;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 5;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 10;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 10;\nint NUM_ROWS = 10;\nint BRICK_WIDTH = 60;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "60",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 50;\nint START_Y = -100;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.MAGENTA);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = -100;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 5;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = -50;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.MAGENTA);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(true);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 100; int y = 100;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 200, 100);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 100; int y = 100;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 200, 100);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 8;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = -50;\nint START_Y = 50;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 8;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 100;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.YELLOW);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "numBricksBase": "6",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "10",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = -100; int y = -100;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 75, 150);\n        // Add color, optional \n        rect.setFilled(true); rect.setColor(Color.YELLOW);\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = -100; int y = -100;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 75, 150);",
            "rectangleColor": "rect.setFilled(true); rect.setColor(Color.YELLOW);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;\nint START_Y = -50;\nint NUM_COLUMNS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nboolean isUpsideDown = false;\nboolean isColumn = false;\nString input = \"7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.YELLOW);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "structure": "diagonal",
            "numColumns": "7",
            "numBricksPerColumn": "varying",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "0",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 100;\nint START_Y = -50;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 5;\nint ROW_SEP = 10;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 1;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(true);\n                    brick.setColor(Color.GREEN);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "6",
            "brickWidth": "20",
            "brickHeight": "30",
            "brickSeparation": "5",
            "rowSeparation": "10",
            "horizontalOffset": "20",
            "holeProbability": "1",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 5;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 30;\nint BRICK_SEP_FIRST_ROW = 10;\nint ROGUE_BRICK_INDEX_FIRST_ROW = 1;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = 150;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 3;\nint BRICK_WIDTH_SECOND_ROW = 20;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 5;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 5;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "30",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 10;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = 1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 150;",
            "brickColor": "Color.GRAY",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 3;",
            "brickWidthSecondRow": "20",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 5;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "11",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;\nint START_Y = 50;\nint NUM_COLUMNS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nboolean isUpsideDown = true;\nboolean isColumn = true;\nString input = \"6, 6, 6, 6, 6, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.YELLOW);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "structure": "column",
            "numColumns": "6",
            "numBricksPerColumn": "constant",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.BLACK);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = -50;\nint START_Y = 50;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nboolean isUpsideDown = true;\nboolean isRightTriangle = false;\nString input = \"16, 15, 14, 13, 12, 11, 10, 9, 8, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "trapezoid",
            "numBricksBase": "16",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "0",
            "rowSeparation": "5",
            "isUpsideDown": "true",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = -300; int y = -100;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 50, 100);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = -300; int y = -100;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 50, 100);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "80",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(true);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 5;;\nint NUM_BRICKS_PER_ROW = 4;;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 50;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.YELLOW);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 5;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 4;",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = -50;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = false;\nString input = \"10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "trapezoid",
            "numBricksBase": "16",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = 100;\nint NUM_ROWS = 16;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROW_SEP = 5;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "16",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "10",
            "rowSeparation": "5",
            "isUpsideDown": "false",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.YELLOW);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 1;\nint ROGUE_DIAGONAL_INDEX = 1;\nint START_X = 100;\nint START_Y = -50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.YELLOW);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 1;",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = -50;\nint START_Y = 50;\nint NUM_ROWS = 13;\nint NUM_BRICKS_BASE = 13;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = true;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "13",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 7;\nint NUM_ROWS = 40;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.YELLOW);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "80",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = 100;\nint NUM_ROWS = 15;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "15",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "10",
            "isUpsideDown": "false",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 1;\nint START_Y = getHeight() - 20;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GREEN);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 1;",
            "startYPosition": "int START_Y = getHeight() - 20;",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 5;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 40;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.MAGENTA);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 40;",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = -50;\nint START_Y = 50;\nint NUM_ROWS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROW_SEP = 5;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 3;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "3",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "10",
            "rowSeparation": "5",
            "horizontalOffset": "20",
            "holeProbability": "3",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 7;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 20;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 100;\nint START_Y_FIRST_ROW = -100;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 3;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 5;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 7;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "20",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 100;",
            "startYFirstRow": "int START_Y_FIRST_ROW = -100;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 3;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 5;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = -50;\nint START_Y = -50;\nint NUM_ROWS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 1;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "3",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "10",
            "horizontalOffset": "20",
            "holeProbability": "1",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;\nint START_Y = 100;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"8, 8, 8, 8, 8, 8, 8, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.ORANGE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 100;",
            "structure": "column",
            "numColumns": "8",
            "numBricksPerColumn": "constant",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "0",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = getHeight() / 2;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLUE);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = getHeight() / 2;",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = -50;\nint START_Y = 100;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.YELLOW);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 5;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "11",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = -50;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "structure": "column",
            "numColumns": "8",
            "numBricksPerColumn": "varying",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 100; int y = 100;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 150, 75);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 100; int y = 100;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 150, 75);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 100;\nint START_Y = 50;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = false;\nString input = \"10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "trapezoid",
            "numBricksBase": "15",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 5;;\nint NUM_BRICKS_PER_ROW = 7;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 2;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 100;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.GREEN);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 5;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 2;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = false;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.MAGENTA);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = false;",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = -50;\nint NUM_COLUMNS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nboolean isUpsideDown = true;\nboolean isColumn = true;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLUE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "structure": "column",
            "numColumns": "6",
            "numBricksPerColumn": "varying",
            "brickWidth": "30",
            "brickHeight": "30",
            "brickSeparation": "0",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = 100;\nint NUM_ROWS = 14;\nint NUM_BRICKS_BASE = 14;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nboolean isUpsideDown = true;\nboolean isRightTriangle = true;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "14",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "0",
            "rowSeparation": "10",
            "isUpsideDown": "true",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = -50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 4;",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = -50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.YELLOW);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 5;;\nint NUM_BRICKS_PER_ROW = 4;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 10;\nint ROW_SEP = 5;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.GREEN);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 5;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 4;",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rowSeparation": "int ROW_SEP = 5;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 50; int y = 50;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 50, 100);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 50; int y = 50;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 50, 100);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = -50;\nint NUM_COLUMNS = 7;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nboolean isUpsideDown = true;\nboolean isColumn = true;\nString input = \"7, 7, 7, 7, 7, 7, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GREEN);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "structure": "column",
            "numColumns": "7",
            "numBricksPerColumn": "constant",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = -300; int y = -100;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 100, 200);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = -300; int y = -100;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 100, 200);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = -50; int y = -50;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 50, 100);\n        // Add color, optional \n        rect.setFilled(true); rect.setColor(Color.MAGENTA);\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = -50; int y = -50;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 50, 100);",
            "rectangleColor": "rect.setFilled(true); rect.setColor(Color.MAGENTA);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 50; int y = 50;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 75, 150);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 50; int y = 50;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 75, 150);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 7;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLUE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "80",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 10;\nint NUM_ROWS = 10;\nint BRICK_WIDTH = 60;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "60",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;\nint START_Y = 100;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.YELLOW);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 100;",
            "structure": "column",
            "numColumns": "8",
            "numBricksPerColumn": "varying",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "0",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 100; int y = 100;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 50, 100);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 100; int y = 100;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 50, 100);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 50;\nint START_Y = -50;\nint NUM_ROWS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 5;\nint ROW_SEP = 5;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 3;\nboolean isUpsideDown = true;\nString input = \"3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.YELLOW);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "3",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "5",
            "rowSeparation": "5",
            "horizontalOffset": "20",
            "holeProbability": "3",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 3;;\nint NUM_BRICKS_PER_ROW = 5;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = -50;\nint START_Y = 50;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.GRAY);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 3;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 3;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 2;\nint START_X = -50;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 3;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 2;",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;\nint START_Y = 50;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nboolean isUpsideDown = false;\nboolean isColumn = false;\nString input = \"8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.MAGENTA);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "structure": "diagonal",
            "numColumns": "8",
            "numBricksPerColumn": "varying",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "0",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 8;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 20;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = 2;\nint START_X_FIRST_ROW = -50;\nint START_Y_FIRST_ROW = -50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 10;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 8;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "20",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = 2;",
            "startXFirstRow": "int START_X_FIRST_ROW = -50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = -50;",
            "brickColor": "Color.GRAY",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 10;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = 50;\nint NUM_ROWS = 16;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = true;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "16",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;;\nint START_Y = 50;;\nint NUM_ROWS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "4",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 100;\nint START_Y = 100;\nint NUM_ROWS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nint HOLE_PROBABILITY = 1;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.MAGENTA);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 100;",
            "numBricksBase": "3",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "10",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "holeProbability": "1",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = -150; int y = -150;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 150, 75);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = -150; int y = -150;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 150, 75);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 4;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.YELLOW);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 4;",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "11",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.YELLOW);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 4;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = -50;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.YELLOW);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 4;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 4;;\nint NUM_BRICKS_PER_ROW = 7;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 100;\nint START_Y = 100;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.GREEN);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 4;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 4;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint ROGUE_ROW_INDEX = 1;\nint ROGUE_DIAGONAL_INDEX = 1;\nint START_X = 100;\nint START_Y = -50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 4;",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 5;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 1;",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 2;\nint START_Y = getHeight() - 20;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.MAGENTA);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startYPosition": "int START_Y = getHeight() - 20;",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 10;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 60;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "60",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 6;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 30;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = 2;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = -50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 30;\nint BRICK_SEP_SECOND_ROW = 10;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + 250;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 6;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "30",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = 2;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = -50;",
            "brickColor": "Color.GRAY",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "30",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 10;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 250;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 10;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.BLACK);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 100;\nint START_Y = 100;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nint HORIZONTAL_OFFSET = -20;\nint HOLE_PROBABILITY = 3;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 100;",
            "numBricksBase": "7",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "10",
            "horizontalOffset": "-20",
            "holeProbability": "3",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;;\nint START_Y = 50;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = true;\nString input = \"7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "7",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "0",
            "rowSeparation": "10",
            "horizontalOffset": "20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 10;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "10",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 100; int y = 100;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 150, 75);\n        // Add color, optional \n        rect.setFilled(true); rect.setColor(Color.MAGENTA);\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 100; int y = 100;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 150, 75);",
            "rectangleColor": "rect.setFilled(true); rect.setColor(Color.MAGENTA);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = -50;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLUE);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 5;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "11",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;\nint START_Y = -50;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.GREEN);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = -50;",
            "structure": "column",
            "numColumns": "8",
            "numBricksPerColumn": "varying",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 8;;\nint NUM_BRICKS_PER_ROW = 5;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 8;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;;\nint START_Y = 50;;\nint NUM_ROWS = 5;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "5",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "10",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;;\nint START_Y = 50;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "7",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.YELLOW);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 2;\nint START_X = 100;\nint START_Y = 50;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 2;",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;;\nint START_Y = -50;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = true;\nString input = \"6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "6",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 10;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = 50;\nint NUM_COLUMNS = 6;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 10;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"6, 6, 6, 6, 6, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.MAGENTA);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "structure": "column",
            "numColumns": "6",
            "numBricksPerColumn": "constant",
            "brickWidth": "20",
            "brickHeight": "30",
            "brickSeparation": "10",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLACK);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 40;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.ORANGE);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 40;",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 5;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.YELLOW);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 4;",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 100;\nint START_Y = 50;\nint NUM_ROWS = 8;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nint HOLE_PROBABILITY = 1;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(true);\n                    brick.setColor(Color.GREEN);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "8",
            "brickWidth": "20",
            "brickHeight": "30",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "holeProbability": "1",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = -150; int y = -150;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 100, 200);\n        // Add color, optional \n        rect.setFilled(true); rect.setColor(Color.GREEN);\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = -150; int y = -150;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 100, 200);",
            "rectangleColor": "rect.setFilled(true); rect.setColor(Color.GREEN);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "80",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 5;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.YELLOW);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 100;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 5;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = -50;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.ORANGE);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 5;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 7;\nint NUM_ROWS = 40;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.YELLOW);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "80",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = 50;\nint NUM_ROWS = 14;\nint NUM_BRICKS_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 5;\nint ROW_SEP = 10;\nboolean isUpsideDown = true;\nboolean isRightTriangle = true;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GREEN);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "5",
            "rowSeparation": "10",
            "isUpsideDown": "true",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 6;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 2;\nint START_X = 100;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLUE);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 2;",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 8;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 20;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = 50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 6;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 30;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 2;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 8;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "20",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 50;",
            "brickColor": "Color.GRAY",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 6;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "30",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 2;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(true);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;\nint START_Y = -50;\nint NUM_COLUMNS = 4;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nboolean isUpsideDown = true;\nboolean isColumn = true;\nString input = \"4, 4, 4, 4\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = -50;",
            "structure": "column",
            "numColumns": "4",
            "numBricksPerColumn": "constant",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "10",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 6;\nint BRICK_WIDTH_FIRST_ROW = 20;\nint BRICK_HEIGHT_FIRST_ROW = 40;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = 1;\nint START_X_FIRST_ROW = -100;\nint START_Y_FIRST_ROW = 50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 4;\nint BRICK_WIDTH_SECOND_ROW = 20;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 5;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 6;",
            "brickWidthFirstRow": "20",
            "brickHeightFirstRow": "40",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = 1;",
            "startXFirstRow": "int START_X_FIRST_ROW = -100;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 50;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 4;",
            "brickWidthSecondRow": "20",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 5;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = -50;\nint NUM_COLUMNS = 3;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"3, 3, 3\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "structure": "column",
            "numColumns": "3",
            "numBricksPerColumn": "constant",
            "brickWidth": "20",
            "brickHeight": "30",
            "brickSeparation": "0",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "80",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 8;;\nint NUM_BRICKS_PER_ROW = 5;;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 2;\nint START_X = 50;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.GRAY);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 8;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 5;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 2;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 1;\nint START_Y = getHeight() / 2;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.ORANGE);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 1;",
            "startYPosition": "int START_Y = getHeight() / 2;",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.YELLOW);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 2;\nint START_Y = getHeight() - 20;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GREEN);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startYPosition": "int START_Y = getHeight() - 20;",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint ROGUE_ROW_INDEX = 1;\nint ROGUE_DIAGONAL_INDEX = 2;\nint START_X = 50;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 5;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 2;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLACK);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "80",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "80",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROW_SEP = 5;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 50;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rowSeparation": "int ROW_SEP = 5;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = getHeight() / 2;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = getHeight() / 2;",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;;\nint START_Y = 100;;\nint NUM_ROWS = 4;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 100;",
            "numBricksBase": "4",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "10",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 50; int y = 50;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 50, 100);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 50; int y = 50;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 50, 100);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = -50;\nint NUM_COLUMNS = 3;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 5;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"3, 3, 3\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "structure": "column",
            "numColumns": "3",
            "numBricksPerColumn": "constant",
            "brickWidth": "20",
            "brickHeight": "30",
            "brickSeparation": "5",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = 50;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = false;\nString input = \"10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "trapezoid",
            "numBricksBase": "14",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = 100;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLUE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 100;",
            "structure": "column",
            "numColumns": "8",
            "numBricksPerColumn": "varying",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "0",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;\nint START_Y = -50;\nint NUM_COLUMNS = 3;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nboolean isUpsideDown = true;\nboolean isColumn = true;\nString input = \"3, 3, 3\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLUE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = -50;",
            "structure": "column",
            "numColumns": "3",
            "numBricksPerColumn": "constant",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "0",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "80",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;;\nint START_Y = 100;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.YELLOW);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 100;",
            "numBricksBase": "6",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "10",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;\nint START_Y = -50;\nint NUM_COLUMNS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 10;\nboolean isUpsideDown = true;\nboolean isColumn = true;\nString input = \"3, 3, 3\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "structure": "column",
            "numColumns": "3",
            "numBricksPerColumn": "constant",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "10",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 2;\nint START_X = 50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = false;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLUE);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = false;",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 50;\nint START_Y = -50;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 5;\nint ROW_SEP = 5;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.ORANGE);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "7",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "5",
            "rowSeparation": "5",
            "horizontalOffset": "20",
            "holeProbability": "2",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = -150; int y = -150;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 100, 50);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = -150; int y = -150;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 100, 50);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 8;\nint BRICK_WIDTH_FIRST_ROW = 20;\nint BRICK_HEIGHT_FIRST_ROW = 40;\nint BRICK_SEP_FIRST_ROW = 10;\nint ROGUE_BRICK_INDEX_FIRST_ROW = 2;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = 50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 8;",
            "brickWidthFirstRow": "20",
            "brickHeightFirstRow": "40",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 10;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = 2;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 50;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 4;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 40;\nint BRICK_SEP_FIRST_ROW = 5;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = -100;\nint START_Y_FIRST_ROW = -100;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLUE);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 7;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 5;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLUE);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 4;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "40",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 5;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = -100;",
            "startYFirstRow": "int START_Y_FIRST_ROW = -100;",
            "brickColor": "Color.BLUE",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 7;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 5;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 5;\nint ROGUE_BRICK_INDEX = 2;\nint START_X = 100;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startXPosition": "int START_X = 100;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 100; int y = 100;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 150, 75);\n        // Add color, optional \n        rect.setFilled(true); rect.setColor(Color.BLUE);\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 100; int y = 100;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 150, 75);",
            "rectangleColor": "rect.setFilled(true); rect.setColor(Color.BLUE);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 2;\nint START_X = 50;\nint START_Y = 100;\nboolean isDiagonal = false;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = 100;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 1;\nint START_X = -50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = false;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLUE);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 1;",
            "startXPosition": "int START_X = -50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = true;",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "80",
            "brickHeight": "20",
            "centeringAssistLines": "add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.BLUE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = -50;\nint START_Y = 100;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = true;\nString input = \"7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 100;",
            "numBricksBase": "7",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "5",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "2",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 10;\nint ROGUE_BRICK_INDEX = 1;\nint START_Y = getHeight() / 2;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.MAGENTA);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 1;",
            "startYPosition": "int START_Y = getHeight() / 2;",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = -50;\nint START_Y = 100;\nint NUM_ROWS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 1;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.ORANGE);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 100;",
            "numBricksBase": "8",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "5",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "1",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = -50;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.BLUE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "6",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "10",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = -300; int y = -100;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 200, 100);\n        // Add color, optional \n        rect.setFilled(true); rect.setColor(Color.GREEN);\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = -300; int y = -100;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 200, 100);",
            "rectangleColor": "rect.setFilled(true); rect.setColor(Color.GREEN);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = 100;\nint NUM_COLUMNS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nboolean isUpsideDown = false;\nboolean isColumn = false;\nString input = \"6, 6, 6, 6, 6, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 100;",
            "structure": "diagonal",
            "numColumns": "6",
            "numBricksPerColumn": "constant",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "0",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = -200; int y = -50;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 100, 50);\n        // Add color, optional \n        rect.setFilled(true); rect.setColor(Color.GREEN);\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = -200; int y = -50;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 100, 50);",
            "rectangleColor": "rect.setFilled(true); rect.setColor(Color.GREEN);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 100;\nint START_Y = -50;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = false;\nString input = \"16, 15, 14, 13, 12, 11, 10, 9, 8, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "trapezoid",
            "numBricksBase": "16",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "5",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 100; int y = 100;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 50, 100);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 100; int y = 100;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 50, 100);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 100;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.GREEN);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 5;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLUE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 3;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 30;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = 1;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = -50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 7;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 2;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 3;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "30",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = 1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = -50;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 7;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 2;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 2;\nint START_X = 50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.ORANGE);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = -50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = false;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "20",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = -50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = true;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = 100;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = false;\nString input = \"15, 14, 13, 12, 11, 10, 9, 8, 7, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "trapezoid",
            "numBricksBase": "15",
            "brickWidth": "20",
            "brickHeight": "30",
            "brickSeparation": "10",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "11",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.YELLOW);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = -50;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.ORANGE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "7",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "5",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;\nint START_Y = -50;\nint NUM_COLUMNS = 5;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 5;\nboolean isUpsideDown = false;\nboolean isColumn = false;\nString input = \"5, 5, 5, 5, 5\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = -50;",
            "structure": "diagonal",
            "numColumns": "5",
            "numBricksPerColumn": "constant",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "5",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = -50;\nint NUM_ROWS = 15;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = true;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.MAGENTA);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "15",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.YELLOW);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 40;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLACK);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 100;\nint START_Y = 50;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = false;\nString input = \"10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "trapezoid",
            "numBricksBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;;\nint START_Y = 50;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "7",
            "brickWidth": "20",
            "brickHeight": "30",
            "brickSeparation": "10",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 40;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLACK);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 2;\nint START_Y = -40;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.ORANGE);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startYPosition": "int START_Y = -40;",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 1;\nint START_Y = getHeight() - 20;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLUE);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 1;",
            "startYPosition": "int START_Y = getHeight() - 20;",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 50;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "7",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 5;;\nint NUM_BRICKS_PER_ROW = 4;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 100;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.GRAY);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 5;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 4;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "80",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 7;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 20;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = -50;\nint START_Y_FIRST_ROW = 50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 7;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 7;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "20",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = -50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 50;",
            "brickColor": "Color.GRAY",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 7;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 50;\nint START_Y = 50;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.ORANGE);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "7",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "5",
            "horizontalOffset": "20",
            "holeProbability": "2",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 3;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 20;\nint BRICK_SEP_FIRST_ROW = 10;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = 150;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.ORANGE);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 6;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 40;\nint BRICK_SEP_SECOND_ROW = 10;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.ORANGE);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 3;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "20",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 10;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 150;",
            "brickColor": "Color.ORANGE",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 6;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "40",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 10;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = -50;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "6",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "10",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 7;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 20;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = 50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 7;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "20",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 50;",
            "brickColor": "Color.GRAY",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 50;\nint START_Y = 50;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROW_SEP = 5;\nint HORIZONTAL_OFFSET = -20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(true);\n                    brick.setColor(Color.MAGENTA);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "7",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "10",
            "rowSeparation": "5",
            "horizontalOffset": "-20",
            "holeProbability": "2",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = -50;\nint NUM_ROWS = 14;\nint NUM_BRICKS_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = true;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 1;\nint START_Y = -40;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 1;",
            "startYPosition": "int START_Y = -40;",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = -50;\nint START_Y = 50;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = false;\nString input = \"10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "trapezoid",
            "numBricksBase": "16",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 100;\nint START_Y = 50;\nint NUM_ROWS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLUE);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "4",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "holeProbability": "2",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "11",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 5;\nint BRICK_WIDTH_FIRST_ROW = 20;\nint BRICK_HEIGHT_FIRST_ROW = 40;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = -100;\nint START_Y_FIRST_ROW = -50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.MAGENTA);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 20;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 10;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.MAGENTA);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 5;",
            "brickWidthFirstRow": "20",
            "brickHeightFirstRow": "40",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = -100;",
            "startYFirstRow": "int START_Y_FIRST_ROW = -50;",
            "brickColor": "Color.MAGENTA",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "20",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 10;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 40;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "80",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = -40;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.MAGENTA);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = -40;",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;\nint START_Y = -50;\nint NUM_COLUMNS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 10;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"3, 3, 3\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "structure": "column",
            "numColumns": "3",
            "numBricksPerColumn": "constant",
            "brickWidth": "30",
            "brickHeight": "30",
            "brickSeparation": "10",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 5;;\nint NUM_BRICKS_PER_ROW = 6;;\nint OFFSET = -20;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = -50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.YELLOW);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 5;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "offset": "int OFFSET = -20;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(true);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = 50;\nint NUM_COLUMNS = 7;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nboolean isUpsideDown = true;\nboolean isColumn = true;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "structure": "column",
            "numColumns": "7",
            "numBricksPerColumn": "varying",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "0",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 50;\nint START_Y = 50;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROW_SEP = 10;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.GREEN);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "6",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "10",
            "rowSeparation": "10",
            "horizontalOffset": "20",
            "holeProbability": "2",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;\nint START_Y = -50;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nboolean isUpsideDown = true;\nboolean isColumn = true;\nString input = \"8, 8, 8, 8, 8, 8, 8, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.BLUE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "structure": "column",
            "numColumns": "8",
            "numBricksPerColumn": "constant",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 5;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100;\nint START_Y = 100;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100;",
            "startYPosition": "int START_Y = 100;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 2;\nint START_Y = getHeight() - 20;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.ORANGE);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startYPosition": "int START_Y = getHeight() - 20;",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Optionally add centering assist lines\n        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "40",
            "centeringAssistLines": "add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 7;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.GRAY);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(true);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 8;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 100;\nint START_Y = -50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.GRAY);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 8;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 10;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = -50;\nint START_Y = 100;\nint NUM_ROWS = 15;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "15",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 100;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;\nint START_Y = -50;\nint NUM_COLUMNS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.ORANGE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = -50;",
            "structure": "column",
            "numColumns": "3",
            "numBricksPerColumn": "varying",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 5;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 5;\nint ROW_SEP = 5;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = -50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.GRAY);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rowSeparation": "int ROW_SEP = 5;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = -50; int y = -50;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 50, 100);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OffCanvasPositions}",
            "offCanvasPosition": "int x = -50; int y = -50;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 50, 100);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = -50;\nint START_Y = 50;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 5;\nint ROW_SEP = 5;\nboolean isUpsideDown = false;\nboolean isRightTriangle = false;\nString input = \"10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.YELLOW);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "trapezoid",
            "numBricksBase": "16",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "5",
            "rowSeparation": "5",
            "isUpsideDown": "false",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 100;\nint START_Y = -50;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = false;\nString input = \"15, 14, 13, 12, 11, 10, 9, 8, 7, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLUE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "trapezoid",
            "numBricksBase": "15",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = -50;\nint START_Y = 100;\nint NUM_ROWS = 15;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "15",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "0",
            "rowSeparation": "10",
            "isUpsideDown": "false",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 100;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = 50;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = false;\nString input = \"15, 14, 13, 12, 11, 10, 9, 8, 7, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.ORANGE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "trapezoid",
            "numBricksBase": "15",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 75; int y = 75;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 150, 75);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 75; int y = 75;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 150, 75);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = -50;\nint NUM_COLUMNS = 7;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 5;\nboolean isUpsideDown = true;\nboolean isColumn = true;\nString input = \"7, 7, 7, 7, 7, 7, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "structure": "column",
            "numColumns": "7",
            "numBricksPerColumn": "constant",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "5",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 100;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.ORANGE);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 6;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 40;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = -50;\nint START_Y_FIRST_ROW = 50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 6;\nint BRICK_WIDTH_SECOND_ROW = 20;\nint BRICK_HEIGHT_SECOND_ROW = 40;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 6;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "40",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = -50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 50;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 6;",
            "brickWidthSecondRow": "20",
            "brickHeightSecondRow": "40",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;\nint START_Y = 50;\nint NUM_COLUMNS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 5;\nboolean isUpsideDown = true;\nboolean isColumn = true;\nString input = \"7, 7, 7, 7, 7, 7, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.MAGENTA);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "structure": "column",
            "numColumns": "7",
            "numBricksPerColumn": "constant",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "5",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;;\nint START_Y = -50;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = true;\nString input = \"6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "6",
            "brickWidth": "20",
            "brickHeight": "30",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 50; int y = 50;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 75, 150);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 50; int y = 50;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 75, 150);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 4;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = getHeight() - 20;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GREEN);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 4;",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = getHeight() - 20;",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 10;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = getHeight() - 20;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GREEN);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = getHeight() - 20;",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 3;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = -50;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.GREEN);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 3;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 100; int y = 100;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 50, 100);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 100; int y = 100;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 50, 100);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 8;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 1;\nint START_X = 100;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.ORANGE);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 8;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "30",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 1;",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(true);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 6;\nint BRICK_WIDTH_FIRST_ROW = 20;\nint BRICK_HEIGHT_FIRST_ROW = 20;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 100;\nint START_Y_FIRST_ROW = -50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 6;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 30;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + 250;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 6;",
            "brickWidthFirstRow": "20",
            "brickHeightFirstRow": "20",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 100;",
            "startYFirstRow": "int START_Y_FIRST_ROW = -50;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 6;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "30",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 250;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = 100;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nboolean isUpsideDown = false;\nboolean isColumn = false;\nString input = \"8, 8, 8, 8, 8, 8, 8, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 100;",
            "structure": "diagonal",
            "numColumns": "8",
            "numBricksPerColumn": "constant",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "0",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 4;;\nint NUM_BRICKS_PER_ROW = 8;;\nint OFFSET = -20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 5;\nint ROW_SEP = 5;\nint ROGUE_ROW_INDEX = 2;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = -50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.GRAY);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 4;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 8;",
            "offset": "int OFFSET = -20;",
            "brickWidth": "30",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rowSeparation": "int ROW_SEP = 5;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 2;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 4;;\nint NUM_BRICKS_PER_ROW = 5;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.MAGENTA);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 4;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = getHeight() - 20;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = getHeight() - 20;",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.YELLOW);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 5;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 40;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = -50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.ORANGE);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 6;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 40;\nint BRICK_SEP_SECOND_ROW = 10;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 2;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.ORANGE);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 5;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "40",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = -50;",
            "brickColor": "Color.ORANGE",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 6;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "40",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 10;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 2;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 100;\nint START_Y = 100;\nint NUM_ROWS = 15;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GREEN);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "15",
            "brickWidth": "20",
            "brickHeight": "30",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 100;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 100;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 200; int y = 50;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 200, 100);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 200; int y = 50;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 200, 100);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 7;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 2;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = -50;\nint START_Y = 50;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.MAGENTA);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 2;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 6;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 20;\nint BRICK_SEP_FIRST_ROW = 5;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = -100;\nint START_Y_FIRST_ROW = -50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 20;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 5;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 6;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "20",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 5;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = -100;",
            "startYFirstRow": "int START_Y_FIRST_ROW = -50;",
            "brickColor": "Color.GRAY",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "20",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 5;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;;\nint START_Y = 50;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.ORANGE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "6",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = -50;;\nint NUM_ROWS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = true;\nString input = \"4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.BLUE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "4",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;;\nint START_Y = -50;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROW_SEP = 10;\nint HORIZONTAL_OFFSET = -20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "7",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "10",
            "rowSeparation": "10",
            "horizontalOffset": "-20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = getHeight() - 20;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.YELLOW);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = getHeight() - 20;",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = -50;\nint NUM_ROWS = 16;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = true;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "16",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 7;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 20;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = -50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 3;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 7;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "20",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = -50;",
            "brickColor": "Color.GRAY",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 3;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = -50;\nint START_Y = -50;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nint HORIZONTAL_OFFSET = -20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = true;\nString input = \"7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "7",
            "brickWidth": "30",
            "brickHeight": "30",
            "brickSeparation": "0",
            "rowSeparation": "10",
            "horizontalOffset": "-20",
            "holeProbability": "2",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 5;\nint ROGUE_BRICK_INDEX = 1;\nint START_X = 50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 1;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 5;\nint ROW_SEP = 5;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = -50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rowSeparation": "int ROW_SEP = 5;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLACK);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "11",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(true);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 50;;\nint NUM_ROWS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = true;\nString input = \"3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "3",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "10",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.YELLOW);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "80",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = false;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 8;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 30;\nint BRICK_SEP_FIRST_ROW = 10;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 100;\nint START_Y_FIRST_ROW = 50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.MAGENTA);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 2;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.MAGENTA);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 8;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "30",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 10;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 100;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 50;",
            "brickColor": "Color.MAGENTA",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 2;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 200; int y = 50;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 50, 100);\n        // Add color, optional \n        rect.setFilled(true); rect.setColor(Color.GREEN);\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 200; int y = 50;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 50, 100);",
            "rectangleColor": "rect.setFilled(true); rect.setColor(Color.GREEN);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 3;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 40;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = 2;\nint START_X_FIRST_ROW = -50;\nint START_Y_FIRST_ROW = 50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 3;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 30;\nint BRICK_SEP_SECOND_ROW = 10;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 3;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "40",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = 2;",
            "startXFirstRow": "int START_X_FIRST_ROW = -50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 50;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 3;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "30",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 10;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 8;\nint BRICK_WIDTH_FIRST_ROW = 20;\nint BRICK_HEIGHT_FIRST_ROW = 20;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = 50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GREEN);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 20;\nint BRICK_HEIGHT_SECOND_ROW = 30;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 2;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GREEN);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 8;",
            "brickWidthFirstRow": "20",
            "brickHeightFirstRow": "20",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 50;",
            "brickColor": "Color.GREEN",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "20",
            "brickHeightSecondRow": "30",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 2;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 150;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;;\nint START_Y = -50;;\nint NUM_ROWS = 5;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.YELLOW);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "5",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "0",
            "rowSeparation": "5",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 50;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = 100;\nint NUM_ROWS = 10;\nint NUM_BRICKS_BASE = 14;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nboolean isUpsideDown = false;\nboolean isRightTriangle = false;\nString input = \"10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "trapezoid",
            "numBricksBase": "14",
            "brickWidth": "20",
            "brickHeight": "30",
            "brickSeparation": "0",
            "rowSeparation": "10",
            "isUpsideDown": "false",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = -50;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = true;\nString input = \"7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.ORANGE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "7",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 5;\nint ROGUE_BRICK_INDEX = 2;\nint START_Y = 40;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLUE);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startYPosition": "int START_Y = 40;",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.YELLOW);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "80",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "11",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 4;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 5;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = getHeight() - 20;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.YELLOW);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 4;",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = getHeight() - 20;",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = -50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = false;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.YELLOW);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = -50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = true;",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;\nint START_Y = 50;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 5;\nboolean isUpsideDown = false;\nboolean isColumn = false;\nString input = \"8, 8, 8, 8, 8, 8, 8, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.MAGENTA);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "structure": "diagonal",
            "numColumns": "8",
            "numBricksPerColumn": "constant",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "5",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 100; int y = 100;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 50, 100);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 100; int y = 100;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 50, 100);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "11",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 6;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 2;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = -50;\nint START_Y = -50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLUE);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 2;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 10;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 10;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 60;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "60",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 75; int y = 75;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 50, 100);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 75; int y = 75;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 50, 100);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 8;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 40;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = 1;\nint START_X_FIRST_ROW = 100;\nint START_Y_FIRST_ROW = -150;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GREEN);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 6;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 40;\nint BRICK_SEP_SECOND_ROW = 5;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GREEN);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 8;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "40",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = 1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 100;",
            "startYFirstRow": "int START_Y_FIRST_ROW = -150;",
            "brickColor": "Color.GREEN",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 6;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "40",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 5;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 7;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLACK);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "80",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 50;;\nint NUM_ROWS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLUE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "3",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "5",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;\nint START_Y = -50;\nint NUM_COLUMNS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 5;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.ORANGE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "structure": "column",
            "numColumns": "7",
            "numBricksPerColumn": "varying",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "5",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = 50;\nint NUM_ROWS = 14;\nint NUM_BRICKS_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "14",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "5",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;;\nint START_Y = -50;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "6",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "10",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 50;\nint START_Y = 50;\nboolean isDiagonal = false;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.ORANGE);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = 50;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = true;",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = -50;\nint NUM_ROWS = 14;\nint NUM_BRICKS_BASE = 14;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "14",
            "brickWidth": "20",
            "brickHeight": "30",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 10;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 60;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLACK);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "60",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.YELLOW);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100;\nint START_Y = 50;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.GREEN);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100;",
            "startYPosition": "int START_Y = 50;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 150; int y = 150;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 50, 100);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 150; int y = 150;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 50, 100);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 5;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 40;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = -100;\nint START_Y_FIRST_ROW = -150;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.YELLOW);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 6;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 30;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.YELLOW);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 5;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "40",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = -100;",
            "startYFirstRow": "int START_Y_FIRST_ROW = -150;",
            "brickColor": "Color.YELLOW",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 6;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "30",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 1;\nint START_Y = getHeight() - 20;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.YELLOW);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 1;",
            "startYPosition": "int START_Y = getHeight() - 20;",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 3;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 1;\nint START_X = -50;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 3;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 5;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 1;",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = getHeight() - 20;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = getHeight() - 20;",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 10;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 2;\nint START_X = -50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startXPosition": "int START_X = -50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 8;\nint BRICK_WIDTH_FIRST_ROW = 20;\nint BRICK_HEIGHT_FIRST_ROW = 20;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = -50;\nint START_Y_FIRST_ROW = 150;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.ORANGE);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 30;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.ORANGE);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 8;",
            "brickWidthFirstRow": "20",
            "brickHeightFirstRow": "20",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = -50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 150;",
            "brickColor": "Color.ORANGE",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "30",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = -50;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = true;\nString input = \"6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.YELLOW);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "6",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = 50;\nint NUM_COLUMNS = 4;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 5;\nboolean isUpsideDown = false;\nboolean isColumn = false;\nString input = \"4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLUE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "structure": "diagonal",
            "numColumns": "4",
            "numBricksPerColumn": "varying",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "5",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 3;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 40;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = -150;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 3;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 40;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 3;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "40",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = -150;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 3;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "40",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 8;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 20;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 100;\nint START_Y_FIRST_ROW = 100;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.ORANGE);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 30;\nint BRICK_SEP_SECOND_ROW = 5;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 2;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.ORANGE);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 8;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "20",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 100;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 100;",
            "brickColor": "Color.ORANGE",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "30",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 5;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 2;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 40;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 10;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLACK);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "10",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 7;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 1;\nint START_X = 100;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.GREEN);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "20",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 10;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 1;",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickFilled": "brick.setFilled(true);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 2;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = -50;\nint START_Y = -50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 2;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLUE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "11",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 50;\nint START_Y = 100;\nint NUM_ROWS = 8;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.YELLOW);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "numBricksBase": "8",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "10",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "2",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = -50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.ORANGE);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = -50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint ROGUE_ROW_INDEX = 2;\nint ROGUE_DIAGONAL_INDEX = 2;\nint START_X = 50;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 5;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 2;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 2;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 10;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 60;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLUE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "60",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 7;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 30;\nint BRICK_SEP_FIRST_ROW = 10;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = -50;\nint START_Y_FIRST_ROW = -50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.MAGENTA);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 6;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 10;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + 250;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.MAGENTA);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 7;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "30",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 10;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = -50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = -50;",
            "brickColor": "Color.MAGENTA",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 6;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 10;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 250;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;;\nint START_Y = 100;;\nint NUM_ROWS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.GREEN);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 100;",
            "numBricksBase": "5",
            "brickWidth": "30",
            "brickHeight": "30",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 100;\nint START_Y = -50;\nint NUM_ROWS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 10;\nint ROW_SEP = 10;\nint HORIZONTAL_OFFSET = -20;\nint HOLE_PROBABILITY = 1;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "3",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "10",
            "rowSeparation": "10",
            "horizontalOffset": "-20",
            "holeProbability": "1",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "80",
            "brickHeight": "20",
            "centeringAssistLines": "add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;;\nint START_Y = -50;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.ORANGE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "6",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 8;;\nint NUM_BRICKS_PER_ROW = 5;;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 2;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 8;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "brickWidth": "20",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 2;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = -50;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 10;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 60;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "60",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 100;\nint START_Y = 50;\nint NUM_ROWS = 16;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.ORANGE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "16",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = -50;\nint START_Y = -50;\nint NUM_ROWS = 5;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 3;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.ORANGE);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "5",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "5",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "3",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "11",
            "brickWidth": "80",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = -50;\nint START_Y = -50;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 10;\nint ROW_SEP = 5;\nint HORIZONTAL_OFFSET = -20;\nint HOLE_PROBABILITY = 1;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.GRAY);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "7",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "10",
            "rowSeparation": "5",
            "horizontalOffset": "-20",
            "holeProbability": "1",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = -40;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = -40;",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 10;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "10",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 7;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "80",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLUE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "11",
            "brickWidth": "80",
            "brickHeight": "20",
            "centeringAssistLines": "add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 50;\nint START_Y = -100;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = -100;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLACK);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 7;\nint NUM_ROWS = 10;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLACK);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "80",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 10;\nint ROGUE_BRICK_INDEX = 2;\nint START_Y = getHeight() / 2;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "30",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startYPosition": "int START_Y = getHeight() / 2;",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;\nint START_Y = 50;\nint NUM_COLUMNS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 10;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"3, 3, 3\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.ORANGE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "structure": "column",
            "numColumns": "3",
            "numBricksPerColumn": "constant",
            "brickWidth": "30",
            "brickHeight": "30",
            "brickSeparation": "10",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 7;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 40;\nint BRICK_SEP_FIRST_ROW = 5;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = -100;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 4;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 7;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "40",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 5;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = -100;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 4;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLUE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "11",
            "brickWidth": "40",
            "brickHeight": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 3;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 20;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 100;\nint START_Y_FIRST_ROW = -100;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 5;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 3;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "20",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 100;",
            "startYFirstRow": "int START_Y_FIRST_ROW = -100;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 5;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;\nint START_Y = 50;\nint NUM_COLUMNS = 7;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"7, 7, 7, 7, 7, 7, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "structure": "column",
            "numColumns": "7",
            "numBricksPerColumn": "constant",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "0",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 3;;\nint NUM_BRICKS_PER_ROW = 6;;\nint OFFSET = -20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 100;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.GRAY);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 3;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "offset": "int OFFSET = -20;",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(true);",
            "rogueBrickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = false;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.GREEN);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = true;",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLACK);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 5;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 40;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = 2;\nint START_X_FIRST_ROW = 100;\nint START_Y_FIRST_ROW = 50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 7;\nint BRICK_WIDTH_SECOND_ROW = 20;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 5;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "40",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = 2;",
            "startXFirstRow": "int START_X_FIRST_ROW = 100;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 50;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 7;",
            "brickWidthSecondRow": "20",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 8;;\nint OFFSET = -20;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 2;\nint ROGUE_DIAGONAL_INDEX = 2;\nint START_X = 50;\nint START_Y = -50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.GRAY);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 8;",
            "offset": "int OFFSET = -20;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 2;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 2;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 10;\nint NUM_ROWS = 10;\nint BRICK_WIDTH = 60;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "60",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 5;\nint ROGUE_BRICK_INDEX = 1;\nint START_Y = getHeight() - 20;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.MAGENTA);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 1;",
            "startYPosition": "int START_Y = getHeight() - 20;",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 7;\nint BRICK_WIDTH_FIRST_ROW = 20;\nint BRICK_HEIGHT_FIRST_ROW = 40;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = 2;\nint START_X_FIRST_ROW = 100;\nint START_Y_FIRST_ROW = 50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + 250;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 7;",
            "brickWidthFirstRow": "20",
            "brickHeightFirstRow": "40",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = 2;",
            "startXFirstRow": "int START_X_FIRST_ROW = 100;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 50;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 250;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 6;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 30;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = -100;\nint START_Y_FIRST_ROW = 50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 7;\nint BRICK_WIDTH_SECOND_ROW = 20;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 5;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 6;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "30",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = -100;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 50;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 7;",
            "brickWidthSecondRow": "20",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 5;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = -50;\nint NUM_ROWS = 15;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "15",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLACK);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 100;\nint START_Y = 50;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 3;\nboolean isUpsideDown = true;\nString input = \"6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLUE);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "6",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "5",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "3",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 7;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "80",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 200; int y = 50;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 100, 200);\n        // Add color, optional \n        rect.setFilled(true); rect.setColor(Color.RED);\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 200; int y = 50;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 100, 200);",
            "rectangleColor": "rect.setFilled(true); rect.setColor(Color.RED);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 10;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "10",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 5;\nint ROGUE_BRICK_INDEX = 2;\nint START_X = 50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLUE);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 5;;\nint NUM_BRICKS_PER_ROW = 4;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = -50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 5;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 4;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 6;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 1;\nint START_X = 100;\nint START_Y = -50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.GRAY);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 1;",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(true);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 100; int y = 100;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 100, 50);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 100; int y = 100;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 100, 50);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 4;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = getHeight() - 20;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.MAGENTA);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 4;",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = getHeight() - 20;",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 2;\nint START_X = 50;\nint START_Y = 50;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = 50;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "80",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 10;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "10",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 50; int y = 50;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 75, 150);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 50; int y = 50;",
            "rectangleOrientation": "{StandingRectangle}",
            "standingRectangleSize": "GRect rect = new GRect(x, y, 75, 150);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;;\nint START_Y = 50;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = true;\nString input = \"7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.ORANGE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "7",
            "brickWidth": "20",
            "brickHeight": "30",
            "brickSeparation": "10",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Optionally add centering assist lines\n        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "40",
            "centeringAssistLines": "add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 1;\nint START_X = 100;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 1;",
            "startXPosition": "int START_X = 100;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 6;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 20;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = -100;\nint START_Y_FIRST_ROW = 150;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLUE);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 20;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLUE);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 6;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "20",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = -100;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 150;",
            "brickColor": "Color.BLUE",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "20",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.YELLOW);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 100;\nint START_Y = 100;\nint NUM_ROWS = 15;\nint NUM_BRICKS_BASE = 15;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "15",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "false",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 100;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 2;\nint START_Y = getHeight() - 20;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLUE);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startYPosition": "int START_Y = getHeight() - 20;",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GRAY);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 2;\nint START_Y = getHeight() - 20;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.YELLOW);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startYPosition": "int START_Y = getHeight() - 20;",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 6;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = -50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLACK);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 10;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = -50;\nint START_Y = 50;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.ORANGE);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = -50;",
            "startYPosition": "int START_Y = 50;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.YELLOW);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 50; int y = 50;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 200, 100);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 50; int y = 50;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 200, 100);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 4;;\nint NUM_BRICKS_PER_ROW = 7;;\nint OFFSET = -20;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.YELLOW);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 4;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "offset": "int OFFSET = -20;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 5;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(true);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 5;\nint BRICK_WIDTH_FIRST_ROW = 30;\nint BRICK_HEIGHT_FIRST_ROW = 20;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = -50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 5;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 2;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 5;",
            "brickWidthFirstRow": "30",
            "brickHeightFirstRow": "20",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = -50;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 5;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 2;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = -50;\nint START_Y = 100;\nint NUM_ROWS = 16;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = true;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "16",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 100;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 1;\nint START_X = 50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = false;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 1;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = true;",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        int x = 75; int y = 75;\n        // Specify size of the rectangle \n        GRect rect = new GRect(x, y, 150, 75);\n        // Add color, optional \n        //no color\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "hello_world",
            "codeStructure": "import acm.graphics.*;\nimport acm.program.*;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n            \n        // Create a rectangle with the specified position \n        {InitialPositionHelloWorld}\n        // Specify size of the rectangle \n        {DrawBlockHelloWorld}\n        // Add color, optional \n        {AddColorHelloWorld}\n\n        // Add the rectangle to the canvas\n        canvas.add(rect);\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"HelloWorld_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "initialPointLocation": "{OnCanvasPositions}",
            "onCanvasPosition": "int x = 75; int y = 75;",
            "rectangleOrientation": "{LyingDownRectangle}",
            "lyingDownRectangleSize": "GRect rect = new GRect(x, y, 150, 75);",
            "rectangleColor": "//no color"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.BLUE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 5;;\nint NUM_BRICKS_PER_ROW = 7;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = -50;\nint START_Y = 100;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.BLUE);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 5;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 7;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 100;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 8;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 20;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = 1;\nint START_X_FIRST_ROW = 50;\nint START_Y_FIRST_ROW = 150;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 20;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 10;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + 200;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 8;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "20",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = 1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 150;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "20",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 10;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 200;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = -40;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GRAY);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = -40;",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "11",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;\nint START_Y = 50;\nint NUM_COLUMNS = 7;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 5;\nboolean isUpsideDown = false;\nboolean isColumn = false;\nString input = \"7, 7, 7, 7, 7, 7, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "structure": "diagonal",
            "numColumns": "7",
            "numBricksPerColumn": "constant",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "5",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 3;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = -50;\nint START_Y = -50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.GRAY);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 3;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "80",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;;\nint START_Y = -50;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = true;\nString input = \"7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GREEN);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "7",
            "brickWidth": "30",
            "brickHeight": "30",
            "brickSeparation": "0",
            "rowSeparation": "10",
            "horizontalOffset": "20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 8;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 2;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 50;\nint START_Y = 50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.BLUE);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 8;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 2;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int NUM_COLUMNS = 15;\nint NUM_ROWS = 20;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int col = 0; col < NUM_COLUMNS; col++) {\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "brick_wall",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersBrickWall}\n\n        // Draw rows of bricks covering the entire screen without offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int col = 0; col < NUM_COLUMNS; col++) {{\n                int x = col * BRICK_WIDTH;\n                int y = row * BRICK_HEIGHT;\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorBrickWall});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"brickWall_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 4;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = getHeight() / 2;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.YELLOW);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 4;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = getHeight() / 2;",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 40;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "11",
            "brickWidth": "80",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_Y = 40;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.MAGENTA);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startYPosition": "int START_Y = 40;",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                brick.setColor(Color.GREEN);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "20",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.ORANGE);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraPerfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "11",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 2;\nint START_Y = getHeight() - 20;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.MAGENTA);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "20",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startYPosition": "int START_Y = getHeight() - 20;",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 6;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = 100;\nint START_Y = -50;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = true;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.GRAY);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 6;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = true;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 5;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = 1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = -50;\nint START_Y = -50;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.ORANGE);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = 1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;\nint START_Y = 100;\nint NUM_COLUMNS = 8;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 0;\nboolean isUpsideDown = false;\nboolean isColumn = true;\nString input = \"8, 8, 8, 8, 8, 8, 8, 8\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "column_structure",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersColumn}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw columns or diagonals of bricks\n        for (int col = 0; col < NUM_COLUMNS; col++) {{\n            int numBricks = NUM_BRICKS[col];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + col * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + i * (BRICK_HEIGHT + BRICK_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorColumn});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"column_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 100;",
            "structure": "column",
            "numColumns": "8",
            "numBricksPerColumn": "constant",
            "brickWidth": "20",
            "brickHeight": "30",
            "brickSeparation": "0",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = -50;;\nint START_Y = 100;;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 10;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6, 7\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 100;",
            "numBricksBase": "7",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "10",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROGUE_BRICK_INDEX = 2;\nint START_Y = getHeight() - 20;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.GREEN);\n            }\n\n            canvas.add(brick);\n        }\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "single_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize starting position and other parameters\n        {InitializeBrickParametersSingleRow}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = i * (BRICK_WIDTH + BRICK_SEP);\n            int y = START_Y - BRICK_HEIGHT / 2;\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorSingleRow});\n            }}\n\n            canvas.add(brick);\n        }}\n    // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"singleRow_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startYPosition": "int START_Y = getHeight() - 20;",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 50;\nint START_Y = 50;\nint NUM_ROWS = 3;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "3",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "5",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "holeProbability": "2",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 50;\nint START_Y = -50;\nint NUM_ROWS = 14;\nint NUM_BRICKS_BASE = 14;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nboolean isUpsideDown = true;\nboolean isRightTriangle = true;\nString input = \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "14",
            "brickWidth": "30",
            "brickHeight": "20",
            "brickSeparation": "10",
            "rowSeparation": "0",
            "isUpsideDown": "true",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = -50;",
            "brickFilled": "brick.setFilled(true);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Optionally add centering assist lines\n        add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "40",
            "centeringAssistLines": "add(new GLine(getWidth() / 2, 0, getWidth() / 2, getHeight()));",
            "brickFilled": "brick.setFilled(true);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 4;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = 2;\nint START_X = 50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 4;",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 2;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 12;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "12",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(true);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 3;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 10;\nint ROGUE_BRICK_INDEX = 1;\nint START_X = -50;\nint START_Y = getHeight() + 60;\nboolean isDiagonal = true;\nboolean isUpRight = true;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 3;",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 1;",
            "startXPosition": "int START_X = -50;",
            "startYPosition": "int START_Y = getHeight() + 60;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = true;",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 5;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = -50;\nint START_Y = -100;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.YELLOW);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 6;",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = -50;",
            "startYPosition": "int START_Y = -100;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 7;;\nint NUM_BRICKS_PER_ROW = 5;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = 1;\nint START_X = 50;\nint START_Y = 50;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(false);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.GREEN);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 7;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = 1;",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 11;\nint BRICK_WIDTH = 80;\nint BRICK_HEIGHT = 20;\n\n        // Optionally add centering assist lines\n        add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(true);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_pyramid",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"offsetPyramid_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "11",
            "brickWidth": "80",
            "brickHeight": "20",
            "centeringAssistLines": "add(new GLine(0, getHeight() / 2, getWidth(), getHeight() / 2));",
            "brickFilled": "brick.setFilled(true);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 6;\nint BRICK_WIDTH_FIRST_ROW = 20;\nint BRICK_HEIGHT_FIRST_ROW = 30;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 100;\nint START_Y_FIRST_ROW = -100;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 30;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 2;\nint START_X_SECOND_ROW = START_X_FIRST_ROW;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + 200;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 6;",
            "brickWidthFirstRow": "20",
            "brickHeightFirstRow": "30",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 100;",
            "startYFirstRow": "int START_Y_FIRST_ROW = -100;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "30",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 2;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + 200;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 3;;\nint NUM_BRICKS_PER_ROW = 8;;\nint OFFSET = 20;;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = -50;\nint START_Y = -50;\nboolean isRogueRow = false;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setColor(Color.YELLOW);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "parallelogram",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersParallelogram}\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * OFFSET;\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    {SetRogueBrickFilled}\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setColor({BrickColorParallelogram});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"parallelogram_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 3;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 8;",
            "offset": "int OFFSET = 20;",
            "brickWidth": "20",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 10;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = -50;",
            "isRogueRow": "boolean isRogueRow = false;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickFilled": "brick.setFilled(false);",
            "rogueBrickFilled": "brick.setFilled(true);",
            "brickColor": "Color.YELLOW"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        int START_X = 100;\nint START_Y = 50;\nint NUM_ROWS = 16;\nint NUM_BRICKS_BASE = 16;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 5;\nboolean isUpsideDown = false;\nboolean isRightTriangle = true;\nString input = \"16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.GRAY);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "right_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the shape and initialize parameters\n        {InitializeShapeParametersRightTriangle}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            for (int i = 0; i < numBricks; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangle});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rightTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "shape": "rightTriangle",
            "numBricksBase": "16",
            "brickWidth": "20",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "5",
            "isUpsideDown": "false",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.GRAY"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 100;;\nint START_Y = 50;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = true;\nString input = \"6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.BLACK);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "6",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Optionally add centering assist lines\n        // No assist lines by default\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                brick.setColor(Color.MAGENTA);\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "offset_extra",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Optionally add centering assist lines\n        {AddCenteringAssistLines}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = OFFSET_Y + getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = OFFSET_X + (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                brick.setColor({BrickColorPyramidExtra});\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"extraOffset_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "40",
            "centeringAssistLines": "// No assist lines by default",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        int START_X = 50;;\nint START_Y = 50;;\nint NUM_ROWS = 6;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\nint BRICK_SEP = 0;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = 20;\nboolean isUpsideDown = false;\nString input = \"1, 2, 3, 4, 5, 6\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n                brick.setColor(Color.ORANGE);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "scalene_triangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Determine the structure and initialize parameters\n        {InitializeStructureParametersRightTriangleHorizontalOffset}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int numBricks = NUM_BRICKS[row];\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < numBricks; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n                brick.setColor({BrickColorRightTriangleHorizontalOffset});\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"scaleneTriangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 50;",
            "startY": "int START_Y = 50;",
            "numBricksBase": "6",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickSeparation": "0",
            "rowSeparation": "0",
            "horizontalOffset": "20",
            "isUpsideDown": "false",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 5;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 30;\nint BRICK_SEP_FIRST_ROW = 0;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = 100;\nint START_Y_FIRST_ROW = 100;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 7;\nint BRICK_WIDTH_SECOND_ROW = 20;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = -1;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 100;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLACK);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 5;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "30",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 0;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = 100;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 100;",
            "brickColor": "Color.BLACK",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 7;",
            "brickWidthSecondRow": "20",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = -1;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 100;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 14;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 20;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "14",
            "brickWidth": "40",
            "brickHeight": "20",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int BRICKS_IN_BASE = 13;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                brick.setFilled(false);\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "perfect",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersPyramid}\n\n        // Draw a pyramid\n        for (int i = 0; i < BRICKS_IN_BASE; i++) {{\n            // Calculate row variables\n            int nBricks = BRICKS_IN_BASE - i;\n            int rowWidth = nBricks * BRICK_WIDTH;\n            double rowY = getHeight() - (i + 1) * BRICK_HEIGHT;\n            double rowX = (getWidth() - rowWidth) / 2.0;\n\n            // Draw a single row\n            for (int j = 0; j < nBricks; j++) {{\n                // Add a single brick\n                double x = rowX + j * BRICK_WIDTH;\n                GRect brick = new GRect(x, rowY, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Determine if the brick is filled\n                {SetBrickFilled}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"perfect_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "bricksInBase": "13",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickFilled": "brick.setFilled(false);"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        int NUM_BRICKS_FIRST_ROW = 8;\nint BRICK_WIDTH_FIRST_ROW = 40;\nint BRICK_HEIGHT_FIRST_ROW = 20;\nint BRICK_SEP_FIRST_ROW = 10;\nint ROGUE_BRICK_INDEX_FIRST_ROW = -1;\nint START_X_FIRST_ROW = -50;\nint START_Y_FIRST_ROW = 50;\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLUE);\n            }\n\n            canvas.add(brick);\n        }\n\n        // Initialize brick parameters for second row\n        int NUM_BRICKS_SECOND_ROW = 8;\nint BRICK_WIDTH_SECOND_ROW = 40;\nint BRICK_HEIGHT_SECOND_ROW = 20;\nint BRICK_SEP_SECOND_ROW = 0;\nint ROGUE_BRICK_INDEX_SECOND_ROW = 2;\nint START_X_SECOND_ROW = START_X_FIRST_ROW + 50;\nint START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setColor(Color.BLUE);\n            }\n\n            add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "two_row",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for first row\n        {InitializeBrickParametersTwoRowsFirstRow}\n\n        // Draw first row of bricks\n        for (int i = 0; i < NUM_BRICKS_FIRST_ROW; i++) {{\n            int x = START_X_FIRST_ROW + i * (BRICK_WIDTH_FIRST_ROW + BRICK_SEP_FIRST_ROW);\n            int y = START_Y_FIRST_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_FIRST_ROW, BRICK_HEIGHT_FIRST_ROW);\n\n            // Add a rogue brick condition for the first row\n            if (i == ROGUE_BRICK_INDEX_FIRST_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsFirstRow});\n            }}\n\n            canvas.add(brick);\n        }}\n\n        // Initialize brick parameters for second row\n        {InitializeBrickParametersTwoRowsSecondRow}\n\n        // Draw second row of bricks\n        for (int i = 0; i < NUM_BRICKS_SECOND_ROW; i++) {{\n            int x = START_X_SECOND_ROW + i * (BRICK_WIDTH_SECOND_ROW + BRICK_SEP_SECOND_ROW);\n            int y = START_Y_SECOND_ROW;\n            GRect brick = new GRect(x, y, BRICK_WIDTH_SECOND_ROW, BRICK_HEIGHT_SECOND_ROW);\n\n            // Add a rogue brick condition for the second row\n            if (i == ROGUE_BRICK_INDEX_SECOND_ROW) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setColor({BrickColorTwoRowsSecondRow});\n            }}\n\n            add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"twoRows_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricksFirstRow": "int NUM_BRICKS_FIRST_ROW = 8;",
            "brickWidthFirstRow": "40",
            "brickHeightFirstRow": "20",
            "brickSeparationFirstRow": "int BRICK_SEP_FIRST_ROW = 10;",
            "rogueBrickIndexFirstRow": "int ROGUE_BRICK_INDEX_FIRST_ROW = -1;",
            "startXFirstRow": "int START_X_FIRST_ROW = -50;",
            "startYFirstRow": "int START_Y_FIRST_ROW = 50;",
            "brickColor": "Color.BLUE",
            "numBricksSecondRow": "int NUM_BRICKS_SECOND_ROW = 8;",
            "brickWidthSecondRow": "40",
            "brickHeightSecondRow": "20",
            "brickSeparationSecondRow": "int BRICK_SEP_SECOND_ROW = 0;",
            "rogueBrickIndexSecondRow": "int ROGUE_BRICK_INDEX_SECOND_ROW = 2;",
            "startXSecondRow": "int START_X_SECOND_ROW = START_X_FIRST_ROW + 50;",
            "startYSecondRow": "int START_Y_SECOND_ROW = START_Y_FIRST_ROW + BRICK_HEIGHT_FIRST_ROW;"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        int NUM_ROWS = 6;;\nint NUM_BRICKS_PER_ROW = 5;;\nint BRICK_WIDTH = 20;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 5;\nint ROW_SEP = 0;\nint ROGUE_ROW_INDEX = -1;\nint ROGUE_DIAGONAL_INDEX = -1;\nint START_X = -50;\nint START_Y = 50;\nboolean isRogueRow = true;\nboolean isRogueDiagonal = false;\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                } else {\n                    brick.setFilled(true);\n                    brick.setColor(Color.GREEN);\n                }\n\n                canvas.add(brick);\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "rectangle",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters for rows\n        {InitializeBrickParametersRectangleRows}\n\n        // Draw rows of bricks\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            for (int i = 0; i < NUM_BRICKS_PER_ROW; i++) {{\n                int x = START_X + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n                GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                // Add a rogue row/diagonal condition\n                if ((row == ROGUE_ROW_INDEX && isRogueRow) || (i == ROGUE_DIAGONAL_INDEX && isRogueDiagonal)) {{\n                    brick.setFilled(true);\n                    brick.setColor(Color.RED);\n                }} else {{\n                    brick.setFilled(true);\n                    brick.setColor({BrickColorRectangle});\n                }}\n\n                canvas.add(brick);\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"rectangle_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numRows": "int NUM_ROWS = 6;",
            "numBricksPerRow": "int NUM_BRICKS_PER_ROW = 5;",
            "brickWidth": "20",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rowSeparation": "int ROW_SEP = 0;",
            "rogueRowIndex": "int ROGUE_ROW_INDEX = -1;",
            "rogueDiagonalIndex": "int ROGUE_DIAGONAL_INDEX = -1;",
            "startX": "int START_X = -50;",
            "startY": "int START_Y = 50;",
            "isRogueRow": "boolean isRogueRow = true;",
            "isRogueDiagonal": "boolean isRogueDiagonal = false;",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        int START_X = 100;\nint START_Y = -50;\nint NUM_ROWS = 7;\nint BRICK_WIDTH = 30;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 10;\nint ROW_SEP = 0;\nint HORIZONTAL_OFFSET = -20;\nint HOLE_PROBABILITY = 2;\nboolean isUpsideDown = true;\nString input = \"7, 6, 5, 4, 3, 2, 1\";\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    brick.setFilled(false);\n                    brick.setColor(Color.BLACK);\n\n                    canvas.add(brick);\n                }\n            }\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "pyramid_like",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\nimport java.util.Random;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize structure parameters\n        {InitializeStructureParametersRoughlySymmetric}\n        \n        // Convert String to int array \n        String[] stringArray = input.split(\",\");\n        int[] NUM_BRICKS = new int[stringArray.length];\n        for (int i = 0; i < stringArray.length; i++) {{\n            NUM_BRICKS[i] = Integer.parseInt(stringArray[i].trim());\n        }}\n\n        Random rand = new Random();\n\n        // Draw rows of bricks with horizontal offset\n        for (int row = 0; row < NUM_ROWS; row++) {{\n            int initialX = START_X + row * HORIZONTAL_OFFSET;\n            for (int i = 0; i < NUM_BRICKS[row]; i++) {{\n                int x = initialX + i * (BRICK_WIDTH + BRICK_SEP);\n                int y = START_Y + row * (BRICK_HEIGHT + ROW_SEP);\n\n                // Randomly decide if there is a hole (missing brick)\n                boolean hasHole = (rand.nextInt(10) < HOLE_PROBABILITY);\n\n                if (!hasHole) {{\n                    GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n                    // Determine if the brick is filled\n                    {SetBrickFilled}\n                    brick.setColor({BrickColorRoughlySymmetric});\n\n                    canvas.add(brick);\n                }}\n            }}\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"pyramidLike_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "startX": "int START_X = 100;",
            "startY": "int START_Y = -50;",
            "numBricksBase": "7",
            "brickWidth": "30",
            "brickHeight": "40",
            "brickSeparation": "10",
            "rowSeparation": "0",
            "horizontalOffset": "-20",
            "holeProbability": "2",
            "isUpsideDown": "true",
            "brickFilled": "brick.setFilled(false);",
            "brickColor": "Color.BLACK"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 4;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 40;\nint BRICK_SEP = 0;\nint ROGUE_BRICK_INDEX = -1;\nint START_X = 100;\nint START_Y = getHeight() - 20;\nboolean isDiagonal = true;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLUE);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 4;",
            "brickWidth": "40",
            "brickHeight": "40",
            "brickSeparation": "int BRICK_SEP = 0;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = -1;",
            "startXPosition": "int START_X = 100;",
            "startYPosition": "int START_Y = getHeight() - 20;",
            "isDiagonal": "boolean isDiagonal = true;",
            "isUpRight": "boolean isUpRight = false;",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        int NUM_BRICKS = 5;\nint BRICK_WIDTH = 40;\nint BRICK_HEIGHT = 30;\nint BRICK_SEP = 5;\nint ROGUE_BRICK_INDEX = 1;\nint START_X = 50;\nint START_Y = 100;\nboolean isDiagonal = false;\nboolean isUpRight = false;\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {\n                if (isUpRight) {\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                } else {\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }\n            } else {\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            } else {\n                brick.setFilled(true);\n                brick.setColor(Color.BLACK);\n            }\n\n            canvas.add(brick);\n        }\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas) {\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }            \n}",
        "choices": {
            "strategies": "diagonal",
            "codeStructure": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{{\n    private static final int CANVAS_WIDTH = 600;\n    private static final int CANVAS_HEIGHT = 400;\n    private static final int IMAGE_WIDTH = 800;\n    private static final int IMAGE_HEIGHT = 600;\n\n    public static void main(String[] args) {{\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Initialize brick parameters\n        {InitializeBrickParametersDiagonal}\n\n        // Draw bricks\n        for (int i = 0; i < NUM_BRICKS; i++) {{\n            int x = START_X;\n            int y = START_Y;\n            if (isDiagonal) {{\n                if (isUpRight) {{\n                    x += i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }} else {{\n                    x -= i * (BRICK_WIDTH + BRICK_SEP);\n                    y -= i * (BRICK_HEIGHT + BRICK_SEP);\n                }}\n            }} else {{\n                y += i * (BRICK_HEIGHT + BRICK_SEP);\n            }}\n            GRect brick = new GRect(x, y, BRICK_WIDTH, BRICK_HEIGHT);\n\n            // Add a rogue brick condition\n            if (i == ROGUE_BRICK_INDEX) {{\n                brick.setFilled(true);\n                brick.setColor(Color.RED);\n            }} else {{\n                brick.setFilled(true);\n                brick.setColor({BrickColorDiagonal});\n            }}\n\n            canvas.add(brick);\n        }}\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas);\n    }}\n    private static void saveCanvasAsImage(GCanvas canvas) {{\n        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics g = image.getGraphics();\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n        // Draw the current canvas content to the buffered image\n        BufferedImage canvasImage = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n        Graphics canvasGraphics = canvasImage.getGraphics();\n        canvasGraphics.setColor(Color.WHITE);\n        canvasGraphics.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        canvas.paint(canvasGraphics);\n\n        // Center the canvas on the image\n        int offsetX = (IMAGE_WIDTH - CANVAS_WIDTH) / 2;\n        int offsetY = (IMAGE_HEIGHT - CANVAS_HEIGHT) / 2;\n        g.drawImage(canvasImage, offsetX, offsetY, null);\n\n        // Draw a border around the canvas area\n        g.setColor(Color.BLACK);\n        g.drawRect(offsetX, offsetY, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Generate a unique filename using a timestamp\n        String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n        String filename = \"diagnal_structure_\" + timestamp + \".png\";\n\n        try {{\n            // Write the buffered image to a file\n            ImageIO.write(image, \"png\", new File(filename));\n            System.out.println(\"Image saved as \" + filename);\n        }} catch (Exception e) {{\n            e.printStackTrace();\n        }}\n    }}            \n}}",
            "numBricks": "int NUM_BRICKS = 5;",
            "brickWidth": "40",
            "brickHeight": "30",
            "brickSeparation": "int BRICK_SEP = 5;",
            "rogueBrickIndex": "int ROGUE_BRICK_INDEX = 1;",
            "startXPosition": "int START_X = 50;",
            "startYPosition": "int START_Y = 100;",
            "isDiagonal": "boolean isDiagonal = false;",
            "isUpRight": "boolean isUpRight = false;",
            "brickColor": "Color.BLACK"
        }
    }
]