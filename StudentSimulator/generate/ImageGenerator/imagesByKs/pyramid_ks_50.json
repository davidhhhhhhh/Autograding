[
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // No horizontal loop but vertical loop\n                // Determine starting point \n                // Random Starting Point\n                    double start_Y = random.nextInt(600);\n                    double start_X = random.nextInt(800);\n                \n                int xOffset = random.nextInt(60);\n                int nRows = 4 + random.nextInt(20);\n                for (int i = 0; i < nRows; i++) {\n                    double x = start_X + i * xOffset;\n                    double y = start_Y - i * brick_height;\n                    // Draw a bricks\n                    GRect brick = new GRect(x, y, brick_width, brick_height);\n                    // Black Color, Not filled\n                    canvas.add(brick);\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "Diagonal",
            "StartingPointVec": "FalseStartPoint",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Constant value of offset, incorrect direction\n                //\n                double rowX = start_X - i * random.nextInt(30);\n                \n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "FalseOffset",
            "FalseOffsetTypes": "RamOffsetFalseDir",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Incorrect brick space, overlap\n                //\n                double rowY = start_Y - i * (1 + random.nextInt(8));                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "OverlapYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Constant nBricks per row\n                int nBricks = num_bricks_base;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "ConstantNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // No offset \n                double rowX = start_X;\n               \n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                         // Color but not filled\n                          \n        brick.setColor(Color.BLUE); \n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "FalseOffset",
            "FalseOffsetTypes": "NoOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "ColorNotFilled",
            "brickColor": "Color.BLUE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Incorrect number of rows, two rows\n                int nRows = 2;\n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Random less nBricks per row\n                //\n                int nBricks = num_bricks_base - random.nextInt(num_bricks_base) + 1;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "TwoRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RamLessBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Too many bricks in base row\n                //\n                int num_bricks_base = 21 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "FalseNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Incorrect number of rows, two rows\n                int nRows = 2;\n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Random more nBricks per row\n                //\n                int nBricks = num_bricks_base + random.nextInt(num_bricks_base) + 1;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Color and filled\n                          \n        brick.setColor(Color.MAGENTA);\n                          brick.setFilled(true);\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "TwoRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RamMoreBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "ColorFilled",
            "brickColor": "Color.MAGENTA"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Only one single row, no vertical loop\n               for (int i = 0; i < num_bricks_base; i++) {\n                   // Single Row, no over lap \n                   // Correct brick space\n                double x = start_X + i * BRICK_WIDTH; \n                   \n                   // Draw a bricks\n                   GRect brick = new GRect(x, start_Y, brick_width, brick_height);\n                   // Black Color, Not filled\n                   canvas.add(brick);\n               }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "SingleRow",
            "singleRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // No offset \n                double rowX = start_X;\n               \n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "FalseOffset",
            "FalseOffsetTypes": "NoOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // No horizontal loop, hello world\n                //\n                GRect brick = new GRect(5 + random.nextInt(700), 5 + random.nextInt(500), brick_width, brick_height);\n                // Black Color, Not filled\n                canvas.add(brick);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HelloWorld",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Incorrect number of rows, two rows\n                int nRows = 2;\n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Constant value of offset, incorrect direction\n                //\n                double rowX = start_X + i * brick_width;\n                \n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Incorrect brick space, extra space\n                //\n                double x = rowX + j * (31 + random.nextInt(30)); \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "TwoRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "FalseOffset",
            "FalseOffsetTypes": "FullOffsetRightDir",
            "multiRowXSpace": "ExtraBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Constant nBricks per row\n                int nBricks = num_bricks_base;\n                    \n                    // Determine rowY value\n                    // Incorrect brick space, extra space\n                //\n                double rowY = start_Y - i * (BRICK_HEIGHT + 1 + random.nextInt(10));                   \n                    \n                    // Determine horizontal offset\n                     // Constant value of offset, correct direction\n                //\n                double rowX = start_X + i * random.nextInt(30);\n               \n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "ConstantNumBricksPerRow",
            "YSpace": "ExtraYSpace",
            "offsetCorrectness": "FalseOffset",
            "FalseOffsetTypes": "RamOffsetRightDir",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Incorrect number of rows, two rows\n                int nRows = 2;\n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "TwoRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Random more nBricks per row\n                //\n                int nBricks = num_bricks_base + random.nextInt(num_bricks_base) + 1;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // No offset \n                double rowX = start_X;\n               \n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Incorrect brick space, extra space\n                //\n                double x = rowX + j * (31 + random.nextInt(30)); \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RamMoreBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "FalseOffset",
            "FalseOffsetTypes": "NoOffset",
            "multiRowXSpace": "ExtraBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // No horizontal loop but vertical loop\n                // Determine starting point \n                // Random Starting Point\n                    double start_Y = random.nextInt(600);\n                    double start_X = random.nextInt(800);\n                \n                int xOffset = random.nextInt(60);\n                int nRows = 4 + random.nextInt(20);\n                for (int i = 0; i < nRows; i++) {\n                    double x = start_X + i * xOffset;\n                    double y = start_Y - i * brick_height;\n                    // Draw a bricks\n                    GRect brick = new GRect(x, y, brick_width, brick_height);\n                    // Black Color, Not filled\n                    canvas.add(brick);\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "Diagonal",
            "StartingPointVec": "FalseStartPoint",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Constant value of offset, correct direction\n                //\n                double rowX = start_X + i * random.nextInt(30);\n               \n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Incorrect brick space, overlap\n                //\n                double x = rowX + j * (1 + random.nextInt(28)); \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                         // Color but not filled\n                          \n        brick.setColor(Color.ORANGE); \n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "FalseOffset",
            "FalseOffsetTypes": "RamOffsetRightDir",
            "multiRowXSpace": "OverlapBrickSpace",
            "BrickStyle": "ColorNotFilled",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Only one single row, no vertical loop\n               for (int i = 0; i < num_bricks_base; i++) {\n                   // Single Row, no over lap \n                   // Correct brick space\n                double x = start_X + i * BRICK_WIDTH; \n                   \n                   // Draw a bricks\n                   GRect brick = new GRect(x, start_Y, brick_width, brick_height);\n                   // Black Color but filled\n                          brick.setFilled(true);\n                   canvas.add(brick);\n               }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "SingleRow",
            "singleRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // No offset \n                double rowX = start_X;\n               \n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "FalseOffset",
            "FalseOffsetTypes": "NoOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Incorrect brick space, overlap\n                //\n                double x = rowX + j * (1 + random.nextInt(28)); \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "OverlapBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Incorrect number of rows, less than a pyramid\n                //\n                int nRows = num_bricks_base - (1 + random.nextInt(3));\n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Incorrect brick space, overlap\n                //\n                double rowY = start_Y - i * (1 + random.nextInt(8));                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "OtherLessRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "OverlapYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        //\n               int brick_width = 30 + random.nextInt(20);\n               int brick_height = 30 - random.nextInt(20);\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Constant nBricks per row\n                int nBricks = num_bricks_base;\n                    \n                    // Determine rowY value\n                    // Incorrect brick space, extra space\n                //\n                double rowY = start_Y - i * (BRICK_HEIGHT + 1 + random.nextInt(10));                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "FalseSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "ConstantNumBricksPerRow",
            "YSpace": "ExtraYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Incorrect number of rows, two rows\n                int nRows = 2;\n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Random less nBricks per row\n                //\n                int nBricks = num_bricks_base - random.nextInt(num_bricks_base) + 1;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "TwoRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RamLessBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Incorrect number of rows, two rows\n                int nRows = 2;\n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "TwoRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Incorrect number of rows, two rows\n                int nRows = 2;\n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Random more nBricks per row\n                //\n                int nBricks = num_bricks_base + random.nextInt(num_bricks_base) + 1;\n                    \n                    // Determine rowY value\n                    // Incorrect brick space, extra space\n                //\n                double rowY = start_Y - i * (BRICK_HEIGHT + 1 + random.nextInt(10));                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "TwoRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RamMoreBricksPerRow",
            "YSpace": "ExtraYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Incorrect brick space, overlap\n                //\n                double x = rowX + j * (1 + random.nextInt(28)); \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "OverlapBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // No horizontal loop, hello world\n                //\n                GRect brick = new GRect(5 + random.nextInt(700), 5 + random.nextInt(500), brick_width, brick_height);\n                // Black Color, Not filled\n                canvas.add(brick);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HelloWorld",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Incorrect number of rows, two rows\n                int nRows = 2;\n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                         // Color but not filled\n                          \n        brick.setColor(Color.ORANGE); \n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "TwoRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "ColorNotFilled",
            "brickColor": "Color.ORANGE"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Random more nBricks per row\n                //\n                int nBricks = num_bricks_base + random.nextInt(num_bricks_base) + 1;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RamMoreBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        //\n               int brick_width = 30 + random.nextInt(20);\n               int brick_height = 30 - random.nextInt(20);\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // No horizontal loop, hello world\n                //\n                GRect brick = new GRect(5 + random.nextInt(700), 5 + random.nextInt(500), brick_width, brick_height);\n                // Black Color, Not filled\n                canvas.add(brick);\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "FalseSize",
            "HLoopExistence": "HelloWorld",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        //\n               int brick_width = 30 + random.nextInt(20);\n               int brick_height = 30 - random.nextInt(20);\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Random less nBricks per row\n                //\n                int nBricks = num_bricks_base - random.nextInt(num_bricks_base) + 1;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Incorrect brick space, overlap\n                //\n                double x = rowX + j * (1 + random.nextInt(28)); \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "FalseSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RamLessBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "OverlapBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Random Starting Point\n                //\n                double start_Y = random.nextInt(600);\n                double start_X = random.nextInt(800);\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "FalseStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Constant nBricks per row\n                int nBricks = num_bricks_base;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                         // Color but not filled\n                          \n        brick.setColor(Color.GREEN); \n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "ConstantNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "ColorNotFilled",
            "brickColor": "Color.GREEN"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Incorrect number of rows, less than a pyramid\n                //\n                int nRows = num_bricks_base - (1 + random.nextInt(3));\n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "OtherLessRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // No offset \n                double rowX = start_X;\n               \n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "FalseOffset",
            "FalseOffsetTypes": "NoOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Constant nBricks per row\n                int nBricks = num_bricks_base;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "ConstantNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Incorrect number of rows, two rows\n                int nRows = 2;\n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "TwoRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // No horizontal loop but vertical loop\n                // Determine starting point \n                // Random Starting Point\n                    double start_Y = random.nextInt(600);\n                    double start_X = random.nextInt(800);\n                \n                int xOffset = random.nextInt(60);\n                int nRows = 4 + random.nextInt(20);\n                for (int i = 0; i < nRows; i++) {\n                    double x = start_X + i * xOffset;\n                    double y = start_Y - i * brick_height;\n                    // Draw a bricks\n                    GRect brick = new GRect(x, y, brick_width, brick_height);\n                    // Black Color, Not filled\n                    canvas.add(brick);\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "Diagonal",
            "StartingPointVec": "FalseStartPoint",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Random more nBricks per row\n                //\n                int nBricks = num_bricks_base + random.nextInt(num_bricks_base) + 1;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RamMoreBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // No horizontal loop but vertical loop\n                // Determine starting point \n                // Random Starting Point\n                    double start_Y = random.nextInt(600);\n                    double start_X = random.nextInt(800);\n                \n                int xOffset = random.nextInt(60);\n                int nRows = 4 + random.nextInt(20);\n                for (int i = 0; i < nRows; i++) {\n                    double x = start_X + i * xOffset;\n                    double y = start_Y - i * brick_height;\n                    // Draw a bricks\n                    GRect brick = new GRect(x, y, brick_width, brick_height);\n                    // Black Color, Not filled\n                    canvas.add(brick);\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "Diagonal",
            "StartingPointVec": "FalseStartPoint",
            "BrickStyle": "NoColorNotFilled"
        }
    },
    {
        "text": "import acm.graphics.*;\nimport java.awt.Color;\nimport java.util.Random;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.imageio.ImageIO;\n\npublic class DrawStructure{\n    private static final int INNER_CANVAS_WIDTH = 600;\n    private static final int INNER_CANVAS_HEIGHT = 400;\n    private static final int OUTER_CANVAS_WIDTH = 800;\n    private static final int OUTER_CANVAS_HEIGHT = 600;\n\n    public static void main(String[] args) {\n        // Create an off-screen GCanvas\n        GCanvas canvas = new GCanvas();\n        canvas.setSize(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n        \n        // Initiate new random\n        Random random = new Random();\n\n        // Initialize brick size\n        int brick_width = 30;\n               int brick_height = 10;\n               int BRICK_WIDTH = brick_width;\n               int BRICK_HEIGHT = brick_height;\n\n        // Horizontal Loop\n        // Determine # of bricks \n                // Suitable # bricks in base row\n                //\n                int num_bricks_base = 7 + random.nextInt(12);\n                int BRICKS_IN_BASE = num_bricks_base;\n                \n               // Determine starting point \n                // Correct Starting Point\n                int baseRowWidth = num_bricks_base * brick_width;\n                double start_Y = 500 - brick_height;\n                double start_X = (canvas.getWidth() - baseRowWidth) / 2.0;\n                \n               // Determine the number of rows\n                // Correct number of rows\n                int nRows = num_bricks_base;\n               \n                \n               // Create a horizontal loop\n                // Vertical loop exist\n               for (int i = 0; i < nRows; i++) {\n                    // Determine # of Bricks per row\n                    // Correct nBricks per row\n                int nBricks = num_bricks_base - i;\n                    \n                    // Determine rowY value\n                    // Correct brick space in Y direction\n                double rowY = start_Y - i * BRICK_HEIGHT;                   \n                    \n                    // Determine horizontal offset\n                     // Correct Offset\n                int rowWidth = nBricks * BRICK_WIDTH;\n                double rowX = (canvas.getWidth() - rowWidth) / 2.0;\n               \n                    \n                    // Draw a single row\n                    for (int j = 0; j < nBricks; j++) {\n                        // Determine horizontal offset\n                        // Correct brick space\n                double x = rowX + j * BRICK_WIDTH; \n                        GRect brick = new GRect(x, rowY, brick_width, brick_height);\n                        // Black Color, Not filled\n                        canvas.add(brick);\n                    }\n                }\n        \n        // Draw the inner canvas boundary\n        GRect innerCanvasBoundary = new GRect((OUTER_CANVAS_WIDTH - INNER_CANVAS_WIDTH) / 2,\n                                               (OUTER_CANVAS_HEIGHT - INNER_CANVAS_HEIGHT) / 2,\n                                               INNER_CANVAS_WIDTH, INNER_CANVAS_HEIGHT);\n        innerCanvasBoundary.setColor(Color.BLACK);\n        canvas.add(innerCanvasBoundary);\n\n        // Save the canvas as an image\n        saveCanvasAsImage(canvas, args[0]);\n    }\n    private static void saveCanvasAsImage(GCanvas canvas, String imageDir) {\n                    BufferedImage image = new BufferedImage(OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT, BufferedImage.TYPE_INT_RGB);\n                    Graphics g = image.getGraphics();\n                    g.setColor(Color.WHITE);\n                    g.fillRect(0, 0, OUTER_CANVAS_WIDTH, OUTER_CANVAS_HEIGHT);\n\n                    // Draw the current canvas content to the buffered image\n                    canvas.paint(g);\n\n                    // Generate a unique filename using a timestamp\n                    String timestamp = new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());\n                    String filename = \"image_\" + timestamp + \".png\";\n\n                    try {\n                        // Write the buffered image to a file\n                        File outputfile = new File(imageDir, filename);\n                        ImageIO.write(image, \"png\", outputfile);\n                        System.out.println(\"Image saved as \" + outputfile.getPath());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }            \n            }",
        "choices": {
            "seriousness": "serious",
            "codeStructure": "common_structure",
            "SizeCorrectness": "CorrectSize",
            "HLoopExistence": "HLoopExist",
            "NumBaseBricks": "RightNumBaseBricks",
            "StartingPoint": "RightStartPoint",
            "NumRows": "RightNumRows",
            "VLoopExistence": "MultipleRows",
            "NumBrickPerRow": "RightNumBricksPerRow",
            "YSpace": "RightYSpace",
            "offsetCorrectness": "RightOffset",
            "multiRowXSpace": "RightBrickSpace",
            "BrickStyle": "NoColorNotFilled"
        }
    }
]